<!-- <!DOCTYPE html> -->

<html>
	<head>
		<title>Mastermind</title>
		<meta charset="utf-8">
		<!-- Load d3.js -->
		<script>

		var booleanDic = {
				true: 1,
				false: 0
				},
				pieceDic = {
				1: ". ",
				2: ": ",
				3: ":.",
				4: "::"
				},
				levelAddress = window.location.href,
				level = levelAddress.charAt(levelAddress.length-2),
				colorOptions = Array("yellow", "blue", "red", "green", "orange", "purple"),
				color1 = colorOptions[Math.floor(Math.random()*colorOptions.length)],
				color2 = colorOptions[Math.floor(Math.random()*colorOptions.length)],
				color3 = colorOptions[Math.floor(Math.random()*colorOptions.length)],
				color4 = colorOptions[Math.floor(Math.random()*colorOptions.length)],
				colorCode = Array(color1, color2, color3, color4),
				maxTurns = {
					1: 12,
					2: 10,
					3: 8
				};

		console.log(colorCode);

		</script>
		<meta name="viewport" content="width=device-width, initial-scale=1">
	</head>
	<body>
		<div id="level_message" align="center"></div>
		<script>

		document.getElementById("level_message").innerHTML = String(maxTurns[level]) + " tries to crack the four color code."

		</script>
		<script src="https://d3js.org/d3.v4.js"></script>
		<!-- Load color palettes -->
		<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
		<!-- Create a div where the graph will take place -->
		<div id="game_board" align="center"></div>
		<!-- Create a div where the color selection will take place -->
		<div id="color_buttons" align="center"></div>
		<script>

		var	height_dic = {
			1: 500,
			2: 427,
			3: 354
		};
		// set the dimensions and margins of the graph
		var margin = {top: 30, right: 25, bottom: 30, left: 25},
			  width = 450 - margin.left - margin.right,
			  height = height_dic[level] - margin.top - margin.bottom;
		// append the svg object to the body of the page
		var svg1 = d3.select("#game_board")
				.append("svg")
				  .attr("width", width + margin.left + margin.right)
				  .attr("height", height + margin.top + margin.bottom)
				.append("g")
				  .attr("transform",
				        "translate(" + margin.left + "," + margin.top + ")");

		var colorDic = {
					"rgb(152, 78, 163)": "purple",
					"rgb(77, 175, 74)": "green",
					"rgb(55, 126, 184)": "blue",
					"rgb(228, 26, 28)": "red",
					"rgb(255, 255, 51)": "yellow",
					"rgb(255, 127, 0)": "orange"
				},
				clickCount = 0,
				maxClicks = {
					1: 48,
					2: 40,
					3: 32
				},
				clickScoreDic = {
				},
				gridScoreDic = {
				},
				guessDic = {
				},
				gridA = 1,
				gridB = 2,
				gridC = 3,
				gridD = 4,
				fillDic = {
					W: 100,
					B: 100
				},
				i;

		for (i = 1; i < maxClicks[level]+1; i++) {
		  fillDic[i] = 100
		};
		for (i = 1; i < maxTurns[level]+1; i++) {
		  clickScoreDic[i] = Array(gridA, gridB, gridC, gridD),
			gridA += 4,
			gridB += 4,
			gridC += 4,
			gridD += 4
		};
		//Read the data
		var createBoard = function(fillDic, guessDic) {
			d3.csv("../assets/game_board" + String(level) + ".csv", function(data) {
			  // Labels of row and columns -> unique identifier of the column called 'group' and 'variable'
			  var turnSlots = d3.map(data, function(d){ return d.group; }).keys(),
						numTurns = d3.map(data, function(d){ return d.variable; }).keys();
			  // Build X and Y scales and axis:
			  var x = d3.scaleBand()
							    .range([ 0, width ])
							    .domain(turnSlots)
							    .padding(0.05),
						y = d3.scaleBand()
							    .range([0, height ])
							    .domain(numTurns)
							    .padding(0.05);

				svg1.append("g")
			    .style("font-size", 15)
			    .call(d3.axisTop(x).tickSize(0))
						.select(".domain").remove()

				svg1.append("g")
			    .style("font-size", 15)
					.call(d3.axisLeft(y).tickSize(0))
			    	.select(".domain").remove()
			  // Build color scale
			  var myColor = d3.scaleSequential()
			    .interpolator(d3.interpolateCubehelixDefault)
			    .domain([1,100])
			  // add the squares
			  var rect = svg1.selectAll()
				    .data(data, function(d) {return d.group+':'+d.variable;})
				    .enter();

				rect.append("rect")
				      .attr("x", function(d) { return x(d.group) })
				      .attr("y", function(d) { return y(d.variable) })
				      .attr("rx", 4)
				      .attr("ry", 4)
				      .attr("width", x.bandwidth() )
				      .attr("height", y.bandwidth() )
				      .style("fill", function(d) { if (clickCount == 0)
																						{return myColor(100)}
																					 else if (fillDic[d.color_index] == 100)
																						{return myColor(100)}
																					 else
																					 	{return fillDic[d.color_index]}
																					})
				      .style("stroke-width", 2)
				      .style("stroke", "black")
				      .style("opacity", 1);

			rect.append("text")
						.attr("x", function(d) { return x(d.group) + 24})
						.attr("y", function(d) { return y(d.variable) + 23})
						.attr("rx", 4)
						.attr("ry", 4)
						.attr("width", x.bandwidth() )
						.attr("height", y.bandwidth() )
			    .text(function(d) { if (d.group=="W" && clickCount%4==0 && clickCount!=0)
															{ var colorCodeCopy = Array(color1, color2, color3, color4);
																		dCount = 0,
																		wCount = 0,
																		guessColors = Array(
																			guessDic[(d.variable*4)-3], guessDic[(d.variable*4)-2], guessDic[(d.variable*4)-1], guessDic[d.variable*4]);
																// console.log(guessDic);
																console.log(guessColors);
																for (i = 0; i < 4; i++) {
																	if (guessColors[i-dCount] == colorCodeCopy[i])
																		{ delete guessColors[i-dCount];
																			delete colorCodeCopy[i-dCount];
																			// console.log(colorCodeCopy);
																			guessColors = guessColors.filter(Boolean);
																			colorCodeCopy = colorCodeCopy.filter(Boolean);
																			// console.log(colorCodeCopy);
																			dCount+=1; }
																}
																// console.log(guessColors.length);
																while (guessColors.length > 0) {
																	if (colorCodeCopy.includes(guessColors[0]))
																	{ wCount+=1,
																	  dIndex = colorCodeCopy.indexOf(guessColors[0]);
																		delete guessColors[0];
																		delete colorCodeCopy[dIndex];
																		guessColors = guessColors.filter(Boolean);
																		colorCodeCopy = colorCodeCopy.filter(Boolean); }
																	else
																		{ delete guessColors[0];
																		  guessColors = guessColors.filter(Boolean); }
																gridScoreDic[d.score_index] = pieceDic[wCount]};
																return gridScoreDic[d.score_index]
														}
														// guess_colors = [self.color_1, self.color_2, self.color_3, self.color_4]
										        // color_delete = self.color_code[:]
										        // guess_check = guess_colors[:]
										        // for guess in self.color_code:
										        //     if guess_check[self.color_index - self.deletion_count]==guess:
										        //         self.black_count += 1
										        //         del(guess_check[self.color_index - self.deletion_count])
										        //         del(color_delete[self.color_index - self.deletion_count])
										        //         self.deletion_count += 1
										        //     self.color_index += 1
										        // while guess_check:
										        //     if guess_check[0] in color_delete:
										        //         self.white_count += 1
										        //         delete_index = color_delete.index(guess_check[0])
										        //         del(guess_check[0])
										        //         del(color_delete[delete_index])
										        //     else:
										        //         del(guess_check[0])

															 // {return d.score_index}
															else if (d.group=="B" && clickCount%4==0 && clickCount!=0)
															{ gridScoreDic[d.score_index] = pieceDic[
																booleanDic[guessDic[(d.variable*4)-3] == colorCode[0]] +
																booleanDic[guessDic[(d.variable*4)-2] == colorCode[1]] +
																booleanDic[guessDic[(d.variable*4)-1] == colorCode[2]] +
																booleanDic[guessDic[(d.variable*4)] == colorCode[3]]];
															 return gridScoreDic[d.score_index] }
															else
															 { return null }
														 })
						.style("font-size", 16)
						.style("stroke-width", 1)
						.style("stroke", "black");

		});};

		createBoard(fillDic);

		var data = [1, 2, 3, 4, 5, 6],
				categorical = [{ "name" : "schemeSet1", "n": 6}],
				colorScale = d3.scaleOrdinal(d3[categorical[0].name]);
		// create a tooltip
		var tooltip = d3.select("#color_buttons")
			.append("div")
				.style("opacity", 0);
		// Three function that change the tooltip when user hover / move / leave a cell
		var mouseover = function(d) {
			d3.select(this)
				.style("stroke-width", 5)
				.style("stroke", "black")
				.style("opacity", 1)
		};

		var mousemove = function(d) {
			tooltip
				.style("left", (d3.mouse(this)[0]+70) + "px")
				.style("top", (d3.mouse(this)[1]) + "px")
		};

		var mouseleave = function(d) {
			tooltip
				.style("opacity", 0)
			d3.select(this)
				.style("stroke-width", 2)
				.style("stroke", "black")
				.style("opacity", 1)
		};

		var r = 150,
		    w = r * 3,
		    h = w,
		    rad = Math.PI/180,
		    interval = 360/data.length;

		var svg2 = d3.select('#color_buttons')
		    .append('svg')
			    .attr('width', w)
			    .attr('height', h)
		    .append('g')
		    	.attr('transform', 'translate(' + r + ',' + r + ')');

		svg2.selectAll("circle")
		    .data(data)
		    .enter()
				.append("circle")
					.style("stroke-width", 3)
					.style("stroke", "black")
					.style("opacity", 1)
			    .attr('fill', function(d, i ) { return colorScale(d); })
			    .attr('r', (w*3.5)/interval)
			    .attr('transform', function (d, i) {
			        return "translate(" + ((w/2-r) * Math.cos((interval*i) * Math.PI/180)) + "," + ((w/2-r) * Math.sin((interval*i) * Math.PI/180)) + ")"})
		    .on("mouseover", mouseover)
		    .on("mousemove", mousemove)
		    .on("mouseleave", mouseleave)
				.on("click", function() {
	          clickCount += 1,
						fillDic[clickCount] = d3.select(this).style("fill"),
						guessDic[clickCount] = colorDic[d3.select(this).style("fill")],
						createBoard(fillDic, guessDic);

				});

		</script>
	</body>
</html>
