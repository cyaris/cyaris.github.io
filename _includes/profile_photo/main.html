<!-- <!DOCTYPE html> -->
<html>
	<head>
		<meta charset='utf-8'>
		<meta name='viewport' content='width=device-width, initial-scale=1'>
		<style>

		/* svg {
			border: 1px solid #000;
		} */

		@media (max-width:500px){
	      #profile_photo {
						display: none;
	      }
				#profile_photo_pixels {
						display: none;
	      }
				#transition_menu {
						display: none;
	      }
				#fireworks {
						display: none;
	      }
			}

	 	/* #profile_photo {
			cursor: url(../img/pizza_cursor.png), auto;
		} */

		svg text {
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
			pointer-events: none;
		}

		</style>
	</head>
	<body>
		<!-- Load d3.js -->
		<script src='https://d3js.org/d3.v4.min.js'></script>
		<!-- Create a div where the graph will take place -->
		<div id='profile_photo' align='center' style='margin-bottom:-411.25px;'></div>
		<div id='profile_photo_pixels' align='center' style='margin-bottom:10px;'></div>
		<script src='https://unpkg.com/d3-simple-slider@1.10.1/dist/d3-simple-slider.min.js'></script>
		<!-- Create a div where the slider will be -->
		<div id='transition_menu' align='center'></div>
		<div id='fireworks' align='center' style='margin-bottom:-650px;'></div>
		<script>


		function getRandomInt(min, max) {

			min = Math.ceil(min);
			max = Math.floor(max);

			// the maximum is exclusive and the minimum is inclusive
			return Math.floor(Math.random() * (max - min) + min);
		}


		function addStdSVG(svgName, divInput, widthInput, heightInput, marginLeftInput, marginTopInput, cursorInput) {

				window[svgName] = d3.select('#' + divInput)
														.append('svg')
															.attr('width', widthInput)
															.attr('height', heightInput)
															.attr('transform', 'translate(' + marginLeftInput + ',' + marginTopInput + ')')
															.style('cursor', cursorInput);
		};


		function addStdText(svgInput, classInput, idInput, textX, textY, fontSize, fontStyle, opacity, strokeWidth, textInput) {

				svgInput.append('text')
					.attr('class', classInput)
					.attr('id', idInput)
					.attr('x', textX)
					.attr('y', textY)
					.attr('pointer-events', 'none')
					.text(textInput)
						.style('fill', 'black')
						.style('font-size', fontSize)
						.style('font-style', fontStyle)
						.style('opacity', opacity)
						.style('stroke-width', strokeWidth)
						.style('stroke', function(d) {
							if ( strokeWidth==0 )
							{ return 'transparent'; }
							else
							 { return 'black'; }
						 });
		};

		// set the dimensions and margins of the graph
		margin = {top: 0, bottom: 15, left: 0, right: 0},
    width = 405,
    height = 405,
		svg3Height = 120,
		svg4Width = width*2,
		svg4Height = height+svg3Height+125,

		// append the svg object to the body of the pageC
		addStdSVG('svg1', 'profile_photo', width, height, margin.left, margin.top, null);
		// a separate svg is needed for the pixels so that they will always be on top, even while objects are appended to the original image (laser eyes).
		addStdSVG('svg2', 'profile_photo_pixels', width, height, margin.left, margin.top, null);
		addStdSVG('svg3', 'transition_menu', width, svg3Height, margin.left, margin.top, null);

		addStdSVG('svg4', 'fireworks', svg4Width, svg4Height, -width*.10, -height*1.6, null);
		svg4.attr('pointer-events', 'none');

		addStdText(svg3, null, 'hover_instructions', 130, 85, '18px', 'italic', 0.80, 0, 'Hover on my face!');

		// credit is due to this blocks page for the process defined below: http://bl.ocks.org/mrtriangle/11222485
		// I took what was there and made adjustments based on preference and version differences, but the basic foundation was all set up on that page.
		executeLaserEyes = function(d) {

			for (var i=1; i<5; ++i) {

				createLaserEye = function(i, cxInput, cyInput) {

					svg1.append('circle')
							.attr('cx', cxInput)
							.attr('cy', cyInput)
							.attr('r', 0.25)
							.style('fill', 'transparent')
							.style('stroke', '#cc0000')
							.style('stroke-width', 7.5/i)
							.transition()
									// this delay is increasingly long for each circle
									// additional seconds are added so that the eyes are stay red for a few seconds before transitioning
									.delay((Math.pow(i, 2.5) * 22.5) + 500)
									.duration(2000)
							.attr('r', 200)
							.style('stroke-opacity', 0)
							.on('end', function() {
								d3.select(this).remove();
							});
					}

					// appending first laser eye
					createLaserEye(i, 177.5, 201.25);
					// appending second laser eye
					createLaserEye(i, 246.75, 197.75);
			}
		}

		// appending the original version of the photo, invisible upon page load.
		// x,y coordinates are relative to the transform translate above.
		svg1.append('svg:image')
			// .attr('id', 'full_resolution_photo')
			.attr('x', 0)
			.attr('y', 0)
			.attr('width', width)
			.attr('height', height)
			.attr('xlink:href', '../img/profile_photo.png')
			.attr('pointer-events', 'none');

		//Read the data
		d3.csv('/assets/profile_photo/proile_photo_pixel_rgb_codes.csv', function(data) {

			// defining time variables as inputs for pixelMO and pixelML tansitions.
			pixelTransDelay = 100,
			pixelTransDuration = 750,
			pixelTransLength = (pixelTransDelay * 2) + (pixelTransDuration * 2);

			// determining input for selectAll based on valid pixels
			function getTransitionSelect(idInput) {

				currentPixel = '#' + idInput,
				xInput = parseInt(idInput.replace('x', '').split('y', 2)[0]),
				yInput = parseInt(idInput.replace('x', '').split('y', 2)[1]),
				// defining neighbors so they'll activate a 3x3 box area of pixels in all directions
				// these each need to be evaluated to confirm that the pixel exists
				neighborPixel1 = '#x' + String(xInput-1) + 'y' + String(yInput-1),
				neighborPixel2 = '#x' + String(xInput-1) + 'y' + String(yInput+1),
				neighborPixel3 = '#x' + String(xInput+1) + 'y' + String(yInput-1),
				neighborPixel4 = '#x' + String(xInput+1) + 'y' + String(yInput+1),
				evaluatingPixels = Array(currentPixel, neighborPixel1, neighborPixel2, neighborPixel3, neighborPixel4);
				transitionSelect = currentPixel;

				for ( var i = 0; i <= evaluatingPixels.length-1; i++ ) {
					if ( d3.select(evaluatingPixels[i]).empty()==false ) {

						transitionSelect+=', ' + evaluatingPixels[i];
					}
				}

				return transitionSelect;
			};

			// credit is due to this blocks page for the process defined below: http://bl.ocks.org/s2t2/53e96654487b4b0ef6e5
			// I took what was there and made adjustments based on preference and version differences, but the basic foundation was all set up on that page.
			function launchFireworks() {

				// since multiple rockets could be active at once, grabbing a random integer to dynamically name the classes
				randomInt = getRandomInt(0, 1000000),
				classInput = 'fireworks_' + randomInt;

				// defining y parameter for the height of the launch
				launchHeight = getRandomInt(svg4Height*0.1, svg4Height*0.4),
				// defining adjusted y parameter for delay preceding explosion
				// new height adjusting for the distance by which the rocket will descend after reaching its peak (prior to exploding)
				explosionHeight = launchHeight + 25;

				// defining values for the launch of the firework
				// function below will be used to determine the x location for launching the rocket
				randomXStart = d3.randomNormal(svg4Width/2, 125),
				// x coordinate for the ascending rocket
				base = randomXStart(),
				randomX = function(b){ return d3.randomNormal(b, 80)()},
				randomY = d3.randomNormal(explosionHeight, 80),
				launchData = d3.range(100).map(function() { return { x: randomX(base), y: randomY() }; });

				// creating an array of separate color palettes for each firework
				fireWorksColorPalettes = [
					// Astrid Gen Wyatt Shyla Cynthia Color Palette
					['#1ecf25', '#9419e6', '#fcd300', '#30cf89', '#19cde6']
					// Bohemian sunset Color Palette
					['#9c2ea1', '#ff5f58', '#ffdd23', '#fd9301', '#ff0055'],
					// KINDA BRIGHT Color Palette
					['#d578ff', '#625df0', '#59e7f2', '#f259a6', '#67eebb'],
					// P a s t e l R a i n b o w Color Palette
					['#ffc5c5', '#bcffa7', '#feffb6', '#98e5e7', '#ffaef3'],
					// pastel colors of the rainbow Color Palette
					['#ffb3ba', '#ffdfba', '#ffffba', '#baffc9', '#bae1ff'],
					// Beach Color Palette
					['#96ceb4', '#ffeead', '#ff6f69', '#ffcc5c', '#88d8b0'],
					// VaporWave Color Palette
					['#ff71ce', '#01cdfe', '#05ffa1', '#b967ff', '#fffb96'],
					// 80s Color Palette
					['#ff48c4', '#2bd1fc', '#f3ea5f', '#c04df9', '#ff3f3f'],
					// Metro UI Colors Color Palette
					['#d11141', '#00b159', '#00aedb', '#f37735', '#ffc425'],
					// neon colors Color Palette
					['#4deeea', '#74ee15', '#ffe700', '#f000ff', '#001eff'],
					// Instagram gradient Color Palette
					['#feda75', '#fa7e1e', '#d62976', '#962fbf', '#4f5bd5'],
					// Rainbow Dash Color Palette
					['#ee4035', '#f37736', '#fdf498', '#7bc043', '#0392cf'],
					// Cyberpunk Color Palette
					['#00ff9f', '#00b8ff', '#001eff', '#bd00ff', '#d600ff'],
					// Metro Style Color Palette
					['#00aedb', '#a200ff', '#f47835', '#d41243', '#8ec127'],
					// ESO MOTD Color Text Color Palette
					['#ff0000', '#fff000', '#18fff9', '#d3ac4b', '#8f139f']
				]

				color = d3.scaleOrdinal().domain([0, Math.max(launchData['x'])]).range(fireWorksColorPalettes[getRandomInt(0, fireWorksColorPalettes.length-1)]);

				svg4.selectAll()
						.data(launchData).enter()
							.append('circle')
							.attr('class', classInput);

				svg4.selectAll('.' + classInput)
						.attr('r', 2)
						.attr('cx', base)
						.attr('cy', svg4Height)
						.style('fill', '#f7df1e')
						.transition()
								.ease(d3.easeCircle)
								.duration(1500)
								.attr('cy', launchHeight)
						.transition()
								.ease(d3.easeCircle)
								.duration(750)
								.attr('r', 7)
								.attr('cy', explosionHeight)
						.transition()
								.ease(d3.easeExp)
								.duration(500)
								.attr('cx', function(d) { return d.x; })
								.attr('cy', function(d) { return d.y; })
								.attr('r', 10)
								.style('fill', function(d) { return color(d.x); })
								.transition()
								.ease(d3.easeCircle)
								.duration(2500)
								.style('opacity', 0)
								.attr('cx', function(d) {
									if ( d.x > base )
									{ return d.x + (d.x - base) }
									else
									{ return d.x - (-d.x + base) }
								})
								.attr('cy', function(d) {
									if ( d.y > explosionHeight )
									{ return d.y + (d.y - explosionHeight ) }
									else
									{ return d.y - (-d.y + explosionHeight ) }
								})
								.attr('r', 0)
								.on('end', function() {
									d3.select(this).remove();
								});
			}

			function countInvisiblePixels() {

				// iterating over all pixels to check the current opacity, and get a percent of total pixels that are invisible.
				totalPixels = svg2.selectAll('.photo_pixels').size(),
				invisiblePixels = 0;

				svg2.selectAll('.photo_pixels')
				  .each(function(d) {

						if ( d3.select(this).style('opacity')==0 )
						{ invisiblePixels+=1 }
				  });

				// labelling dynamically the percent of the non-pixelated photo that's fully visible.
				svg3.select('#percent_revealed').remove();
				percentFormat = d3.format('.2f');
				numberInput = percentFormat((invisiblePixels/totalPixels)*100)
				textInput = 'Percent Revealed: ' + numberInput + '%'
				addStdText(svg3, null, 'percent_revealed', 120, 110, '15px', 'normal', 0.80, 0, textInput);

				return numberInput
			}

			// the percent of total pixels revealed will be continuously updated every x (see limit) seconds
			// this will stop once the percent reaches 100, and a new timer will be initiated to launch the fireworks (with a timeout provided)
			pixelCountTimer = d3.interval(function() {

				percentRevealed = countInvisiblePixels();
			  if ( percentRevealed>=10 ) {

					pixelCountTimer.stop();
					fireWorksDelayTime = 1750;
					fireWorksTimer = d3.interval(launchFireworks, fireWorksDelayTime);
					// this will set an end to the interval function called above after x iterations
					d3.timer(function(elapsed) {
					  if (elapsed > fireWorksDelayTime*10)
						{ fireWorksTimer.stop(); }
					}, fireWorksDelayTime*10);
				}
			}, 1000);

			pixelMO = function(d) {

				transitionSliderMode = transitionSlider.value(),
				thisID = d3.select(this).attr('id'),
				transitionSelect = getTransitionSelect(thisID);

				svg2.selectAll(transitionSelect)
					.style('stroke-width', 0.3)
					.transition()
						.delay(pixelTransDelay)
						.duration(pixelTransDuration)
						.attr('x', function(d) { return x(d.x_coordinate) + 1.5})
						.attr('y', function(d) { return y(d.y_coordinate) - 1})
						.attr('width', x.bandwidth()/1.5)
						.attr('height', y.bandwidth()/1.5)
						.attr('transform', function(d) { return 'rotate(45,' + (x(d.x_coordinate) + ((x.bandwidth()-(x.bandwidth()/1.5))/2)) + ',' + (y(d.y_coordinate) + ((y.bandwidth()-(y.bandwidth()/1.5)))) + ')'})
					.transition()
						.delay(pixelTransDelay)
						.duration(pixelTransDuration)
						.style('opacity', 0);
			},

			pixelML = function(d) {

				transitionSliderMode = transitionSlider.value(),
				thisID = d3.select(this).attr('id'),
				transitionSelect = getTransitionSelect(thisID);

				if ( transitionSliderMode==2 ) {

					svg2.selectAll(transitionSelect)
						.transition()
							.delay(pixelTransLength + 500)
							.duration(pixelTransDuration)
							.attr('x', function(d) { return x(d.x_coordinate) })
							.attr('y', function(d) { return y(d.y_coordinate) })
							.attr('width', x.bandwidth())
							.attr('height', y.bandwidth())
							.attr('transform', function(d) { return 'rotate(0,'  + ( (x(d.x_coordinate) + ((x.bandwidth()-(x.bandwidth()/1.5))/2))) + ',' + ( (y(d.y_coordinate) + ((y.bandwidth()-(y.bandwidth()/1.5))/2))) + ')'})
							.style('stroke-width', 0.3)
							.style('opacity', 1)
						.transition()
							.delay(pixelTransDelay)
							.duration(pixelTransDuration)
							.style('stroke-width', 0.075);
				};
			};

			// Labels of row and columns -> unique identifier of the column called 'xCoordinate' and 'yCoordinate'
			pixelX = d3.map(data, function(d){ return d.x_coordinate; }).keys(),
			pixelY = d3.map(data, function(d){ return d.y_coordinate; }).keys();

			// Build X and Y scales and axis:
			// Scaling the pixels within the space of the svg.
			x = d3.scaleBand().range([0, width]).domain(pixelX).padding(0),
			y = d3.scaleBand().range([0, height]).domain(pixelY).padding(0);

			function addPixelRects() {

				// adding the 48x48 pixels that will make up the profile photo
			  rect = svg2.selectAll()
				    .data(data, function(d) { return d.x_coordinate+':'+d.y_coordinate; })
				    .enter();

				rect.append('rect')
							.attr('class', 'photo_pixels')
							.attr('id', function(d) { return 'x' + String(parseInt(d.x_coordinate)) + 'y' + String(parseInt(d.y_coordinate))})
							.attr('x', function(d) { return x(d.x_coordinate) })
				      .attr('y', function(d) { return y(d.y_coordinate) })
				      .attr('rx', 0)
				      .attr('ry', 0)
				      .attr('width', x.bandwidth())
				      .attr('height', y.bandwidth())
							.style('stroke', 'white')
							.style('stroke-width', 0.075)
				      .style('fill', function(d) { return 'rgb(' + String(parseInt(d.r)) + ',' + String(parseInt(d.g)) + ',' + String(parseInt(d.b)) + ')'})
							.on('mouseover', pixelMO)
							.on('mouseleave', pixelML);
			};

			addPixelRects();

			sliderData = [0, 1, 2],
			sliderDataLabels = {0: 'Reveal Mode', 1: 'Reveal My Laser Vision Mode', 2: 'Transition Mode'},
			transitionSlider = d3.sliderBottom()
									.min(d3.min(sliderData))
		    					.max(d3.max(sliderData))
		    					.width(300)
									.step(1)
									.ticks(3)
									.default(d3.min(sliderData))
									.tickValues(sliderData)
									.tickFormat(function(d, i) { return sliderDataLabels[i]; })
									.on('onchange', val => {

												d3.selectAll('.photo_pixels').remove();
												addPixelRects();
												if ( val==1 )
												// manually inputting a number slightly larger the how long it will take for final laser eye circle will finish transition (delay included).
												// the final transition was calculated by adding the delay from the highest i value with the duration seconds.
												{ timer = d3.interval(executeLaserEyes, 3000); }
												else
												{ timer.stop(); }
									});

			svg3.append('g')
					.attr('id', 'transition_slider')
					.attr('transform', 'translate(50,10)')
					.call(transitionSlider);

			// overriding feature in built-in function that makes current selection invisible
			d3.selectAll('.axis .tick text').style('stroke-width', 0).attr('font-size', '12px').attr('fill', 'black').style('opacity', 0.75);
			// making ticks on axis black
			d3.selectAll('.axis line').style('stroke', 'black');

			});

		</script>
	</body>
</html>
