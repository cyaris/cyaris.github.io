<!-- <!DOCTYPE html> -->
<html>
	<head>
		<style type='text/css'>

			@media (max-width:500px){
		      #profile_photo {
							display: none;
		      }
					#profile_photo_pixels {
							display: none;
		      }
					#transition_menu {
							display: none;
		      }
				}

			svg text {
				stroke: black;
				fill: black;
			  background: white;
			}

		 	/* #profile_photo {
				cursor: url({{site.url}}/assets/img/pizza_cursor.png), auto;
			} */

		</style>
	</head>
	<body>
		<script src='https://chancejs.com/chance.min.js'></script>
		<!-- Create a div where the graph will take place -->
		<div id='profile_photo' align='center' style='margin-bottom:-406.25px;'></div>
		<div id='profile_photo_pixels' align='center' style='margin-bottom:15px;'></div>
		<script src='https://unpkg.com/d3-simple-slider@1.10.1/dist/d3-simple-slider.min.js'></script>
		<!-- Create a div where the slider will be -->
		<div id='transition_menu' align='center' style='margin-bottom:25px;'></div>
		<!-- <div id='fireworks' align='center' style='margin-bottom:-650px;'></div> -->
		<script type='text/javascript'>

			// set the dimensions and margins of the graph
			margin = {top: 0, bottom: 15, left: 0, right: 0},
		  width = 405,
		  height = 405,
			svg3Height = 120;

			// append the svg object to the body of the page.
			addStdSVG('svg1', 'profile_photo', width, height, margin.left, margin.top, null);
			// a separate svg is needed for the pixels so that they will always be on top, even while objects are appended to the original image (laser eyes).
			addStdSVG('svg2', 'profile_photo_pixels', width, height, margin.left, margin.top, null);
			addStdSVG('svg3', 'transition_menu', width, svg3Height, margin.left, margin.top, null);

			addStdText(svg3, null, 'hover_instructions', 130, 85, '18px', 'normal', 0.80, 0, 'Hover on my face!');

			// credit is due to this blocks page for the process defined below: http://bl.ocks.org/mrtriangle/11222485
			// I took what was there and made adjustments launchXLocd on preference and version differences, but the basic foundation was all set up on that page.
			executeLaserEyes = function(d) {

				for ( var i=1; i<=4; ++i ) {

					createLaserEye = function(i, cxInput, cyInput) {

						svg1.append('circle')
								.attr('cx', cxInput)
								.attr('cy', cyInput)
								.attr('r', 0.25)
								.style('fill', 'transparent')
								.style('stroke', '#cc0000')
								.style('stroke-width', 7.5)
								.transition()
									// this delay is increasingly long for each circle
									// additional seconds are added so that the eyes are stay red for a few seconds before transitioning
									.delay((i*225) + 500)
									.duration(2000)
									.attr('r', 200)
									.style('stroke-width', 0)
									.style('stroke-opacity', 0)
									.on('end', function() {
										d3.select(this).remove();
									});
						}

						// appending first laser eye
						createLaserEye(i, 177.5, 201.25);
						// appending second laser eye
						createLaserEye(i, 246.75, 197.75);
				}
			}

			// appending the original version of the photo, invisible upon page load.
			// x,y coordinates are relative to the transform translate above.
			svg1.append('svg:image')
					.attr('class', 'no_selection no_events')
					// .attr('id', 'full_resolution_photo')
					.attr('x', 0)
					.attr('y', 0)
					.attr('width', width)
					.attr('height', height)
					.attr('xlink:href', '{{site.url}}/assets/img/profile_photo.png');

			//Read the data
			d3.csv('{{site.url}}/assets/csv/profile_photo/proile_photo_pixel_rgb_codes.csv', function(data) {

				// defining time variables as inputs for pixelMO and pixelML tansitions.
				pixelTransDelay = 100,
				pixelTransDuration = 750,
				pixelTransLength = (pixelTransDelay * 2) + (pixelTransDuration * 2);

				// determining input for selectAll launchXLocd on valid pixels
				function getTransitionSelect(idInput, mouseFunction) {

					currentPixel = '#' + idInput,
					xInput = parseInt(idInput.replace('x', '').split('y', 2)[0]),
					yInput = parseInt(idInput.replace('x', '').split('y', 2)[1]);

					// defining neighbors so they'll activate a 3x3 box area of pixels in all directions
					// these each need to be evaluated to confirm that the pixel exists
					// each of these will be checked individually to see their current opacity
					// only those that are not invisible will be needed (since those are already fully transitioned)
					transitionPixels = Array(currentPixel);

					function getPixelCoordinateString(xCoordinateInput, xAdjustment, yCoordinateInput, yAdjustment) {

						return '#x' + String(xCoordinateInput+xAdjustment) + 'y' + String(yCoordinateInput+yAdjustment);
					}

					transitionPixels.push(getPixelCoordinateString(xInput, 2, yInput, 2)),
					transitionPixels.push(getPixelCoordinateString(xInput, 2, yInput, 1)),
					transitionPixels.push(getPixelCoordinateString(xInput, 2, yInput, 0)),
					transitionPixels.push(getPixelCoordinateString(xInput, 2, yInput, -1)),
					transitionPixels.push(getPixelCoordinateString(xInput, 2, yInput, -2)),
					transitionPixels.push(getPixelCoordinateString(xInput, -2, yInput, 2)),
					transitionPixels.push(getPixelCoordinateString(xInput, -2, yInput, 1)),
					transitionPixels.push(getPixelCoordinateString(xInput, -2, yInput, 0)),
					transitionPixels.push(getPixelCoordinateString(xInput, -2, yInput, -1)),
					transitionPixels.push(getPixelCoordinateString(xInput, -2, yInput, -2)),
					transitionPixels.push(getPixelCoordinateString(xInput, 1, yInput, 2)),
					transitionPixels.push(getPixelCoordinateString(xInput, 1, yInput, -2)),
					transitionPixels.push(getPixelCoordinateString(xInput, -1, yInput, 2)),
					transitionPixels.push(getPixelCoordinateString(xInput, -1, yInput, -2)),
					transitionPixels.push(getPixelCoordinateString(xInput, 0, yInput, 2)),
					transitionPixels.push(getPixelCoordinateString(xInput, 0, yInput, -2));

					transitionSelect = '';

					// creating conditional for whether it's a mouseover or mouseleave
					// goal here is to limit transitions that are unnecesarry (ex: transitioning an invisible object)
					for ( var i=1; i<=transitionPixels.length; i++ ) {

						if ( d3.select(transitionPixels[i]).empty()==false && (
							(mouseFunction=='pixelMO' && d3.select(transitionPixels[i]).style('opacity')!=0 )
							// doing all possible transitions for mouseleave
							// this will only apply to transition mode
							|| mouseFunction=='pixelML'
						)) {
								// creating a string that will have all ids needed for transition select statements
								if ( transitionSelect=='' )
								{ transitionSelect = transitionPixels[i]; }
								else
								{ transitionSelect+=', ' + transitionPixels[i]; }
						}
					}

					return transitionSelect;
				};

				function countInvisiblePixels() {

					// iterating over all pixels to check the current opacity, and get a percent of total pixels that are invisible.
					totalPixels = svg2.selectAll('.photo_pixels').size(),
					invisiblePixels = 0;

					svg2.selectAll('.photo_pixels')
					  .each(function(d) {

							if ( d3.select(this).style('opacity')==0 )
							{ invisiblePixels+=1 }
					  });

					// labelling dynamically the percent of the non-pixelated photo that's fully visible.
					svg3.select('#percent_revealed').remove();

					percentFormat = d3.format('.2f'),
					numberInput = percentFormat((invisiblePixels/totalPixels)*100),
					textInput = 'Percent Revealed: ' + numberInput + '%';

					// if ( numberInput>=50 ) {
					// 	fillColor = '#cc0000';
				 	// 	fontWeight = ((numberInput-50) * 16) + 100;
					// }
					// else {
					// 	fillColor = 'black',
					// 	fontWeight = 0;
					// }

					addStdText(svg3, null, 'percent_revealed', 117.5, 110, '15px', 'normal', 0.80, 0, textInput);

					return numberInput
				}

				// the percent of total pixels revealed will be continuously updated every x (see limit) seconds
				// once the percent reaches 100, the fireworks will be launched, and not launched again unless the mode is changed (resetting the percentage to zero)
				launchedAlready = false;

				pixelCountTimer = d3.interval(function() {

				percentRevealed = countInvisiblePixels();
					if ( percentRevealed>=90 && launchedAlready==false ) {
						// making all pixels invisible once the once has revealed 90% of the photo.
						svg2.selectAll('.photo_pixels').style('opacity', 0);
						launchedAlready = true,
						// total fireworks in the regular show
						totalFireworks1 = 150,
						// duration per firework of the regular show
						fireWorkInterval1 = 1500,
						// total fireworks in the grand finale
						totalFireWorks2 = 25,
						// duration per firework of the grand finale show
						fireWorkInterval2 = 500;

						for ( var i=1; i<=totalFireworks1+totalFireWorks2; i++ ) {

							// all fireworks for the regular show
							if ( i<=totalFireworks1 )
							{	d3.timeout(launchFireworkBurst, Math.max(fireWorkInterval1, (fireWorkInterval1*i) + chance.floating({ min: -2500, max: 2500 }))); }
							else
							// time for the grand finale!!!
							{	d3.timeout(launchFireworkBurst, Math.max((fireWorkInterval1*totalFireworks1), (fireWorkInterval1*totalFireworks1) + (fireWorkInterval2*(i-totalFireworks1)) + chance.floating({ min: -2500, max: 2500 }))); }
						}
					}
				}, 500);

				pixelMO = function(d) {

					transitionSliderMode = transitionSlider.value(),
					thisID = d3.select(this).attr('id'),
					transitionSelect = getTransitionSelect(thisID, 'pixelMO');

					// checking that the selector is not empty
					if ( transitionSelect!='' ) {

						svg2.selectAll(transitionSelect)
							.style('stroke-width', 0.3)
							.transition()
								.delay(pixelTransDelay)
								.duration(pixelTransDuration)
								// .ease(d3.easeQuad)
								.attr('x', function(d) { return x(d.x_coordinate) + 1.5})
								.attr('y', function(d) { return y(d.y_coordinate) - 1})
								.attr('width', x.bandwidth()/1.5)
								.attr('height', y.bandwidth()/1.5)
								.attr('transform', function(d) { return 'rotate(45,' + (x(d.x_coordinate) + ((x.bandwidth()-(x.bandwidth()/1.5))/2)) + ',' + (y(d.y_coordinate) + ((y.bandwidth()-(y.bandwidth()/1.5)))) + ')'})
							.transition()
								.delay(pixelTransDelay)
								.duration(pixelTransDuration)
								.style('opacity', 0);
								// .on('end', function() {
								// 	// // pixels will be recreated when the slider is used
								// 	// // removing those that have been activated for reveal modes.
								// 	if ( transitionSliderMode!=2 )
								// 	{ svg2.selectAll(transitionSelect).remove(); }
								// });
						}
				},

				pixelML = function(d) {

					transitionSliderMode = transitionSlider.value(),
					thisID = d3.select(this).attr('id'),
					transitionSelect = getTransitionSelect(thisID, 'pixelML');

					if ( transitionSliderMode==2 ) {

						svg2.selectAll(transitionSelect)
							.transition()
								.delay(pixelTransLength + 500)
								.duration(pixelTransDuration)
							// .ease(d3.easeQuad)
								.attr('x', function(d) { return x(d.x_coordinate) })
								.attr('y', function(d) { return y(d.y_coordinate) })
								.attr('width', x.bandwidth())
								.attr('height', y.bandwidth())
								.attr('transform', function(d) { return 'rotate(0,'  + ( (x(d.x_coordinate) + ((x.bandwidth()-(x.bandwidth()/1.5))/2))) + ',' + ( (y(d.y_coordinate) + ((y.bandwidth()-(y.bandwidth()/1.5))/2))) + ')'})
								.style('stroke-width', 0.3)
								.style('opacity', 1)
							.transition()
								.delay(pixelTransDelay)
								.duration(pixelTransDuration)
								.style('stroke-width', 0.075);
					}
				};

				// Labels of row and columns -> unique identifier of the column called 'xCoordinate' and 'yCoordinate'
				pixelX = d3.map(data, function(d) { return d.x_coordinate; }).keys(),
				pixelY = d3.map(data, function(d) { return d.y_coordinate; }).keys();

				// Build X and Y scales and axis:
				// Scaling the pixels within the space of the svg.
				x = d3.scaleBand().range([0, width]).domain(pixelX).padding(0),
				y = d3.scaleBand().range([0, height]).domain(pixelY).padding(0);

				function addPixelRects() {

					// adding the 48x48 pixels that will make up the profile photo
				  rect = svg2.selectAll()
					    .data(data, function(d) { return d.x_coordinate+':'+d.y_coordinate; })
					    .enter();

					rect.append('rect')
								.attr('class', 'photo_pixels')
								.attr('id', function(d) { return 'x' + String(parseInt(d.x_coordinate)) + 'y' + String(parseInt(d.y_coordinate))})
								.attr('x', function(d) { return x(d.x_coordinate) })
					      .attr('y', function(d) { return y(d.y_coordinate) })
					      .attr('rx', 0)
					      .attr('ry', 0)
					      .attr('width', x.bandwidth())
					      .attr('height', y.bandwidth())
								.style('stroke', 'white')
								.style('stroke-width', 0.075)
					      .style('fill', function(d) { return 'rgb(' + String(parseInt(d.r)) + ',' + String(parseInt(d.g)) + ',' + String(parseInt(d.b)) + ')'})
								.on('mouseover', pixelMO)
								.on('mouseleave', pixelML);
				};

				addPixelRects();

				sliderData = [0, 1, 2],
				sliderDataLabels = {0: 'Reveal Mode', 1: 'Reveal My Laser Vision Mode', 2: 'Transition Mode'},
				transitionSlider = d3.sliderBottom()
										.min(d3.min(sliderData))
			    					.max(d3.max(sliderData))
			    					.width(300)
										.step(1)
										.ticks(3)
										.default(d3.min(sliderData))
										.tickValues(sliderData)
										.tickFormat(function(d, i) { return sliderDataLabels[i]; })
										.on('onchange', val => {

													d3.selectAll('.photo_pixels').remove();
													addPixelRects();
													if ( val==1 )
													// manually inputting a number slightly larger the how long it will take for final laser eye circle will finish transition (delay included).
													// the final transition was calculated by adding the delay from the highest i value with the duration seconds.
													{ timer = d3.interval(executeLaserEyes, 3000); }
													else
													{ timer.stop(); }
													// fireworks can be launched again since the percent revealed will be back to zero.
													launchedAlready = false;
										});

				svg3.append('g')
						.attr('id', 'transition_slider')
						.attr('transform', 'translate(50,10)')
						.call(transitionSlider);

				// overriding feature in built-in function that makes current selection invisible
				d3.selectAll('.axis .tick text').style('stroke-width', 0).attr('font-size', '12px').attr('fill', 'black').style('opacity', 0.75);
				// making ticks on axis black
				d3.selectAll('.axis line').style('stroke', 'black');

			});

		</script>
	</body>
</html>
