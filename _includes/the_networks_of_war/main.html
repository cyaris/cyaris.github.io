<!-- <!DOCTYPE html> -->
<html>
	<head>
		<title>The Networks of War</title>
	 <!-- subtitle: Network Analysis Between Countries at War  -->
		<meta charset='utf-8'>
		<meta name='viewport' content='width=device-width, initial-scale=1'>
		<link href='https://fonts.googleapis.com/css2?family=Libre+Franklin:wght@100;400&display=swap' rel='stylesheet'>
		<style>

		@media (max-width:660px){
	      #war_network_analysis {
						display: none;
	      }
				#war_menu {
						display: none;
	      }
				#hover_statistics {
						display: none;
	      }
				#message {
						display: none;
	      }
				#list_of_data_sources {
						display: none;
	      }
			}

		@media (min-width:660px){
			#hidden_project_explained {
				display: none;
	    }
	  }

		/* svg {
			border: 1px solid #000;
		} */

		svg text {
			font-family: 'Libre Franklin', sans-serif;
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
			/* pointer-events: none; */
		}

		</style>
	</head>
	<body>

		<div id='hidden_project_explained' align='left' style='margin-bottom:15px;'>
			<p>While I'm flattered you came to check out my project, it has several interactive features that work best on desktop. So, grab a computer and come back soon!</p>
		</div>
		<div id='message'>
		  <p>Hey there! I'm developing a tool to analyze the networks between countries at war, using data provided by <a href='https://correlatesofwar.org/' target='_blank'>The Correlates of War Project</a>. This project is currently in progress. Stay tuned soon for more updates.</p>
		</div>
		<!-- Create a div where overall metrics will be -->
		<div id='war_menu' align='center' style='margin-bottom:15px;'></div>
		<!-- Create a div where overall metrics will be -->
		<div id='hover_statistics' align='center' style='margin-bottom:10px;'></div>
		<!-- <div id='hover_statistics' align='center' style='margin-bottom:-7.5px;'></div> -->
		<!-- Create a div where the graph will take place -->
		<div id='war_network_analysis' align='center' style='margin-bottom:15px;'></div>
		<div id='list_of_data_sources' align='left' style='margin-bottom:15px;'>
			<p>All data has been obtained from the <a href='https://correlatesofwar.org/' target='_blank'>Correlates of War Project</a>, using all of the following files in some capacity:
				<ul>
					<li>COW Country Codes: COW country codes.csv</li>
					<li>COW War Data, 1816 - 2007</li>
						<ul>
							<li>Inter-StateWarData_v4.0.csv</li>
							<li>INTRA-STATE_State_participants v5.1.csv</li>
							<li>Extra-StateWarData_v4.0.csv</li>
							<li>directed_dyadic_war.csv</li>
						</ul>
					<li>Colonial/Dependency Contiguity: contcold.csv</li>
					<li>Direct Contiguity: contdird.csv</li>
					<li>Defense Cooperation Agreement Dataset: DCAD-v1.0-dyadic.csv</li>
					<li>Diplomatic Exchange: Diplomatic_Exchange_2006v1.csv</li>
					<li>Formal Alliances: alliance_v4.1_by_dyad_yearly.csv</li>
					<li>Militarized Interstate Disputes: dyadic MIDs 3.1.csv</li>
					<li>National Material Capabilities: NMC_5_0-wsupplementary.csv</li>
					<li>Intergovernmental Organizations: dyadic_formatv3.csv</li>
					<li>Territorial Change: tc2018.csv</li>
					<li>Trade: Dyadic_COW_4.0.csv</li>
				</ul>
			</p>
			</div>
		<!-- Load d3.js -->
		<script src='https://d3js.org/d3.v5.min.js'></script>
		<script src='https://d3js.org/d3-time.v2.min.js'></script>
		<script src='../js/node_modules/lodash/lodash.js'></script>
		<script>

		// import _ from '../js/lodash'
		// new code section: functions with non-built-in parameters (functions not of d or something like that).
		function getTextWidth(svgInput, textInput, fontSize) {

			// obtaining length of any textinput (based on default font size and font family)
			var textWidthArray = [];

			svgInput.append('g')
							.selectAll('.dummyText')
							.data([textInput])
							.enter().append('text')
								.attr('pointer-events', 'none')
								// .attr('font-family', 'sans-serif')
								.attr('font-size', fontSize)
								.text(function(d) { return d; })
								.each(function(d,i) {
										var thisWidth = this.getComputedTextLength();
										textWidthArray.push(thisWidth);
										this.remove();
					});

			{
				var textWidth = textWidthArray.reduce((a, b) => a + b, 0);
				return textWidth;
			}
		};

		function addStdText(svgInput, classInput, idInput, textX, textY, fontSize, strokeWidth, textInput) {

			svgInput.append('text')
				.attr('class', classInput)
				.attr('id', idInput)
				.attr('x', textX)
				.attr('y', textY)
				.attr('pointer-events', 'none')
				.text(textInput)
					.style('fill', 'black')
					.style('font-size', fontSize)
					.style('stroke-width', strokeWidth)
					.style('stroke', function(d) {
						if ( strokeWidth==0 )
						{ return 'transparent' }
						else
						 { return 'black' }
					 });
		};

		function addStdRect(svgInput, classInput, idInput, rectX, rectY, rectWidth, rectHeight, rectStroke, rectStrokeWidth, rectStrokeOpacity, rectFill, rectFillOpacity, rMO, rML, rClick) {

			svgInput.append('rect')
						.attr('class', classInput)
						.attr('id', idInput)
						.attr('x', rectX)
						.attr('y', rectY)
						.attr('width', rectWidth)
						.attr('height', rectHeight)
						.style('stroke', rectStroke)
						.style('stroke-width', rectStrokeWidth)
						.attr('stroke-opacity', rectStrokeOpacity)
						.style('fill', rectFill)
						.attr('fill-opacity', rectFillOpacity)
						.on('mouseover', rMO)
						.on('mouseleave', rML)
						.on('click', rClick);
		};

		function nameFitsInNode(svgInput, nodeRadius, nameInput, textSize) {
			// adjusting text position when it does not fit inside the node
			if ( nodeRadius * 2 > getTextWidth(svgInput, nameInput, textSize) + 12.5 )
			{ return true }
			else
			{ return false };

		}

		function nameVerticalShift(svgInput, nodeRadius, participantName, textSize) {
			// adjusting text position when it does not fit inside the node
			if ( nameFitsInNode(svgInput, nodeRadius, participantName, textSize)==false )
			{ return nodeRadius + 25 }
			else
			{ return 5 };

		}

		function nameHorizontalShift(svgInput, nodeRadius, participantName, textSize) {
			// adjusting text position when it does not fit inside the node
			if ( nameFitsInNode(svgInput, nodeRadius, participantName, textSize)==false )
			{ return 20 }
			else
			{ return 0 };

		};
		// set the dimensions and margins of the graph
		var margin = {top: 0, bottom: 15, left: 0, right: 0},
				width = 750,
				height = 500;

		var generalRectMO = function(d) {

					d3.select(this)
						.style('stroke-width', 2)
						.style('cursor', 'pointer');
		},
				generalRectML = function(d) {

					d3.select(this)
						.style('stroke-width', 1);
		};

		// reading in the data to create the war menu
		d3.csv('../assets/the_networks_of_war/war_file_list.csv').then(function(data) {

			var warPageURL = window.location.href,
					warPageType = warPageURL.split('the_networks_of_war_')[1].split('s/')[0],
					warNameLengths = [],
					// creating a dummy svg so that the gettextwidth function can be used before any 'real' svgs are defined
					svgDummy = d3.select('#war_menu').append('svg').attr('width', 0).attr('height', 0),
					fileDic = {
						'file_name' : [],
						'war_name': [],
						'start_year': [],
						'end_year': [],
						'start_date': [],
						'end_date': [],
						'war_type': [],
						'war_sub_type': [],
						'ongoing_war': [],
						'start_date_estimated': [],
						'end_date_estimated': [],
						'total_days_in_war': [],
						'total_participants': []
				};

			var parseTime = d3.timeParse('%Y-%m-%d');

			data.forEach(function(d, i) {
				// determining the war type for each row in the file.
				var fileWarType = d.war_type.toLowerCase().replace('-', '_').replace(' ', '_');
				// performing the following actions if the war type in the file matches the war type for the page.
				if ( warPageType==fileWarType )
				{ fileDic['file_name'].push(d.file_name),
					fileDic['war_name'].push(d.war_name),
					warNameLengths.push(getTextWidth(svgDummy, d.war_name, '15px')),
					fileDic['start_year'].push(parseInt(d.start_year)),
					fileDic['end_year'].push(parseInt(d.end_year)),
					fileDic['start_date'].push(parseTime(d.start_date)),
					fileDic['end_date'].push(parseTime(d.end_date)),
					fileDic['war_type'].push(d.war_type),
					fileDic['war_sub_type'].push(d.war_sub_type),
					fileDic['ongoing_war'].push(parseInt(d.ongoing_war)),
					fileDic['start_date_estimated'].push(parseInt(d.start_date_estimated)),
					fileDic['end_date_estimated'].push(parseInt(d.end_date_estimated)),
					fileDic['total_participants'].push(parseInt(d.total_participants));
					if ( fileDic['start_date_estimated'][i]==1 || fileDic['end_date_estimated'][i]==1 )
					{ estimationFlag = ' *' }
					else
					{ estimationFlag = ' ' }
					if ( fileDic['ongoing_war'][i]==1 )
					{ fileDic['total_days_in_war'].push((d3.timeDay.count(fileDic['start_date'][i], new Date()) + 1).toLocaleString() + estimationFlag); }
					else
					{ fileDic['total_days_in_war'].push(parseInt(d.total_days_in_war).toLocaleString() + estimationFlag);	}
				 }
			});

			var warNameMaxLength = warNameLengths.reduce(function(a, b) { return Math.max(a, b) });
			// removing all svgs to this point (only includes dummy svg)
			d3.selectAll('svg').remove();
			// new code section: start of code for svg1
			// adding createMenu function here so that the as much can be pre-defined as possible.
			// this will reduce runtime needed to re-execute the menu upon returning
			var createMenu = function() {

				var svg1 = d3.select('#war_menu')
						.append('svg')
							.attr('width', width)
							.attr('height', (Object.keys(fileDic['file_name']).length+2) * 30)
							.attr('transform',
						        'translate(' + margin.left + ',' + margin.top + ')')
							.style('cursor', 'pointer');

				// first rect is an outline for the entire menu
				// shifting width (width-2) to allow for stroke to be seen (same reason for adjusting the height)
				addStdRect(svg1, null, null, 1,  1, width-2, ((Object.keys(fileDic['file_name']).length+1) * 30) + 10 - 1, 'black', 1, null, 'transparent', null, null, null, null);
				// creating the labels for the menu (everything in the top row)
				addStdRect(svg1, null, null, 0,  0, width, 40, 'black', 1, 0.15, 'black', 0.075, null, null, null);
				addStdText(svg1, null, null, 10, 25, '15px', 0.75, 'Name');
				addStdText(svg1, null, null, warNameMaxLength + 55, 25, '15px', 0.75, 'Timeframe');
				addStdText(svg1, null, null, warNameMaxLength + 190, 25, '15px', 0.75, 'Length in Days');
				addStdText(svg1, null, null, warNameMaxLength + 330, 25, '15px', 0.75, 'Total Participants');

				// Three function that change the tooltip when user hover / move / leave a rectangle on the menu
				var menuMouseOver = function(d) {

						d3.select(this)
							.style('stroke-width', 2)
							.style('stroke-opacity', 0.75)
							.style('fill', 'rgb(26,188,156)')
							.style('fill-opacity', 0.20);
				 },
					menuMouseLeave = function(d) {

						d3.select(this)
							.style('stroke-width', 1)
							.style('stroke-opacity', 0.15)
							.style('fill', 'black')
							.style('fill-opacity', 0.075);
					},
					menuChoice = function(d) {
						// removing all current svgs
						d3.selectAll('svg').remove();
						createNetworkGraph(d3.select(this).attr('id'));
						window.scrollTo(0, 325);
					};

				for ( var i = 0; i <= Object.keys(fileDic['file_name']).length-1; i++ ) {

					addStdRect(svg1, null, fileDic['file_name'][i], 0,  (30*(i+1))+10, width, 30, 'black', 1, 0.15, 'black', 0.075, menuMouseOver, menuMouseLeave, menuChoice);
					addStdText(svg1, null, null, 10, 30*(i+2), '15px', 0, fileDic['war_name'][i]);

					if ( fileDic['ongoing_war'][i]==1 )
					{ addStdText(svg1, null, null, warNameMaxLength + 45, 30*(i+2), '15px', 0, fileDic['start_year'][i] + ' - Present'); }
					else if ( fileDic['start_year'][i]==fileDic['end_year'][i] )
					{ addStdText(svg1, null, null, warNameMaxLength + 45, 30*(i+2), '15px', 0, fileDic['start_year'][i]); }
					else
					{ addStdText(svg1, null, null, warNameMaxLength + 45, 30*(i+2), '15px', 0, fileDic['start_year'][i] + ' - ' + fileDic['end_year'][i]); }
						addStdText(svg1, null, null, warNameMaxLength + 210, 30*(i+2), '15px', 0, fileDic['total_days_in_war'][i].toLocaleString());
						addStdText(svg1, null, null, warNameMaxLength + 385, 30*(i+2), '15px', 0, fileDic['total_participants'][i].toLocaleString());

			};
				// var randomFileName = fileDic['file_name'][Math.floor(Math.random() * Object.keys(fileDic['file_name']).length)];
		}
		// calling the war menu function upon page load
		createMenu();

		var createNetworkGraph = function(fileName) {
			// new code section: start of code for svg2
			// reading in the data to create the network graph
			d3.json('../assets/the_networks_of_war/json_files_by_war/' + fileName).then(function(graph) {

				// adding area for descriptive statistics to be activated upon hovering nodes.
				var svg2 = d3.select('#hover_statistics')
						.append('svg')
							.attr('width', width)
							.attr('height', 300)
							.attr('transform',
						        'translate(' + margin.left + ',' + margin.top + ')');

				var svg2BodyMO = function(d) {

					svg2.selectAll('.link_descriptor_dropdowns').remove();
					svg2.select('#link_dropdown_selected_text').style('opacity', 1);

					svg2.selectAll('.part_descriptor_dropdowns').remove();
					svg2.select('#part_dropdown_selected_text').style('opacity', 1);
				};

				addStdRect(svg2, null, null, 0, 0, width, 300, 'black', 1, null, 'transparent', null, svg2BodyMO, null, null);

				var warDic = {};
				// not sure how to do this without a loop, but there's only one grow in this section of the json file
				graph.war.forEach(function(d) {
						warDic['war_num'] = d.war_num,
						warDic['war_name'] = d.war_name,
						warDic['war_type_code'] = d.war_type_code,
						warDic['war_type'] = d.war_type,
						warDic['war_sub_type'] = d.war_sub_type,
						warDic['lagging_war'] = d.lagging_war,
						warDic['leading_war'] = d.leading_war;
				});

				// Three functions that change the tooltip when user hover / move / leave a rectangle on the menu
				var backToMenuMouseOver = function(d) {
						d3.select(this)
							.style('stroke-width', 2)
							.style('cursor', 'pointer');
				 },
					 backToMenuMouseLeave = function(d) {
							d3.select(this)
								.style('stroke-width', 1)
					},
						backToMenuClick = function(d) {
							// removing all current svgs
							d3.selectAll('svg').remove();
							createMenu();
					};
				// creating a rect for a back to menu button
				addStdRect(svg2, null, 'back_to_menu', 1,  1, 70, 30, 'black', 1, null, 'transparent', null, backToMenuMouseOver, backToMenuMouseLeave, backToMenuClick);
				addStdText(svg2, null, null, 6, 22.5, '15px', 0, '↖ Menu');
				addStdText(svg2, null, null, 0, 92.5, '15px', 0, warDic['war_name']);

				var participantFields = Object.keys(graph.nodes[0]),
						linkFields = Object.keys(graph.links[0]),
						descriptiveFields = {
							'participant': [],
							'dyadic': []
						}
						descriptorNameLengths = {
							'participant': [],
							'dyadic': []
						}
				// console.log(participantFields);
				for ( var i = 0; i <= linkFields.length-1; i++ ) {
					// getting an array of all descriptive dyadic fields that have at least one record > 0 (binary yes)
					if ( linkFields[i].slice(-2)=='_z' && d3.max(graph.links, function(d) { return d[linkFields[i]] }) > 0 )
					// { descriptiveFields['dyadic'].push(linkFields[i].split('_z')[0]); }
					{ descriptiveFields['dyadic'].push(linkFields[i]);
						// getting an array of name lengths for all items added
						descriptorNameLengths['dyadic'].push(getTextWidth(svg2, linkFields[i], '12px'));
					 }
				};

				var nonDescriptivePartFields =
						[
							'id',
							'war_type_code',
							'c_code',
							'participant',
							'side',
							'start_date',
							'start_year',
							'end_date',
							'end_year',
							'lagging_war',
							'leading_war',
							'ongoing_participation'
						];

				for ( var i = 0; i <= participantFields.length-1; i++ ) {

						if ( nonDescriptivePartFields.includes(participantFields[i])==false ) {
							descriptiveFields['participant'].push(participantFields[i]);
							// getting an array of name lengths for all items added
							descriptorNameLengths['participant'].push(getTextWidth(svg2, participantFields[i], '12px'));
						}
				};

				var totalLinkDescriptors = descriptiveFields['dyadic'].length,
						totalPartDescriptors = descriptiveFields['participant'].length;
						// descriptiveFields['participant'] = descriptiveFields['participant'].sort(),
						// descriptiveFields['dyadic'] = descriptiveFields['dyadic'].sort();

				var getLinkDescriptorValues = function(descriptor_type, linkDescriptorInput) {

					// will need to return this array to make it global
					var linkDescriptorValues = [];

					graph.links.forEach(function(link) {

						if ( parseInt(link[descriptiveFields[descriptor_type][linkDescriptorInput]]) > 0 )
						{ linkDescriptorValues.push(1) }
						else
						{ linkDescriptorValues.push(0) }
					})
					{ return linkDescriptorValues }
				};

				var linkDescriptorValues = getLinkDescriptorValues('dyadic', 0);

				// Three functions that change the the selection for link dash marks (based on interaction variables).
				var linkMenuMouseOver = function(d) {

						d3.select(this)
							.style('stroke-width', 2)
							.style('cursor', 'pointer');
// addStdRect(svgInput, classInput, idInput, rectX, rectY, rectWidth, rectHeight, rectStroke, rectStrokeWidth, rectStrokeOpacity, rectFill, rectFillOpacity, rMO, rML, rClick) {
						svg2.selectAll('.link_descriptor_dropdowns').remove();
						svg2.select('#link_dropdown_selected_text').style('opacity', 0);

							// console.log(document.getElementById('#link_dropdown_selected_text').toString().split('>')[1]);
						for ( var i = 0; i <= descriptiveFields['dyadic'].length-1; i++ ) {
							addStdRect(svg2, 'link_descriptor_dropdowns', 'link_descriptor_dropdown_' + i, width-linkDescriptorMaxNameWidth-10, 1 + ((i+1)*30), linkDescriptorMaxNameWidth+10, 30, 'black', 1, null, 'transparent', null, generalRectMO, generalRectML, linkMenuClick);
							addStdText(svg2, 'link_descriptor_dropdowns', null, width-linkDescriptorMaxNameWidth-5, 22.5 + ((i+1)*30), '12px', 0, descriptiveFields['dyadic'][i]);
						}
					},
					 linkMenuMouseLeave = function(d) {

						 d3.select(this)
	 						.style('stroke-width', 1);
					},
						linkMenuClick = function(d) {

							link_descriptor_indice = parseInt(d3.select(this).attr('id').slice(-1)),
							linkDropDownSelected = descriptiveFields['dyadic'][link_descriptor_indice];

							svg2.selectAll('.link_descriptor_dropdowns').remove();
							svg2.selectAll('#link_dropdown_selected_text').remove();

							addStdRect(svg2, null, 'link_dropdown_selected_rect', width-linkDescriptorMaxNameWidth-10, 1, linkDescriptorMaxNameWidth+10, 30, 'black', 1, null, 'transparent', null, linkMenuMouseOver, linkMenuMouseLeave, null);
							addStdText(svg2, null, 'link_dropdown_selected_text', width-linkDescriptorMaxNameWidth-5, 22.5, '12px', 0, linkDropDownSelected);
							// svg2.select('#link_dropdown_selected_rect').attr('pointer-events', 'none');

							linkDescriptorValues = getLinkDescriptorValues('dyadic', link_descriptor_indice);

							link.selectAll('.link_dash')
									// .transition().duration(1000)
									.attr('stroke', function(d) {
										if ( linkDescriptorValues[d.index] <= 0 )
										{ return 'transparent' }
										else
										{ return 'blue' }
									});
				};


				// Three functions that change the the selection for participant node sizes
				var partMenuMouseOver = function(d) {

						d3.select(this)
							.style('stroke-width', 2)
							.style('cursor', 'pointer');

						svg2.selectAll('.part_descriptor_dropdowns').remove();
						svg2.select('#part_dropdown_selected_text').style('opacity', 0);

						for ( var i = 0; i <= descriptiveFields['participant'].length-1; i++ ) {
							addStdRect(svg2, 'part_descriptor_dropdowns', 'part_descriptor_dropdown_' + i, width-partDescriptorMaxNameWidth-300, 1 + ((i+1)*30), partDescriptorMaxNameWidth+10, 30, 'black', 1, null, 'transparent', null, generalRectMO, generalRectML, partMenuClick);
							addStdText(svg2, 'part_descriptor_dropdowns', null, width-partDescriptorMaxNameWidth-295, 22.5 + ((i+1)*30), '12px', 0, descriptiveFields['participant'][i]);
						}
					},
					 partMenuMouseLeave = function(d) {

						 d3.select(this)
	 						.style('stroke-width', 1);
					},
						partMenuClick = function(d) {

							part_descriptor_indice = parseInt(d3.select(this).attr('id').slice(-1)),
							partDropDownSelected = descriptiveFields['participant'][part_descriptor_indice];

							svg2.selectAll('.part_descriptor_dropdowns').remove();
							svg2.selectAll('#part_dropdown_selected_text').remove();

							addStdRect(svg2, null, 'part_dropdown_selected_rect', width-partDescriptorMaxNameWidth-300, 1, partDescriptorMaxNameWidth+10, 30, 'black', 1, null, 'transparent', null, partMenuMouseOver, partMenuMouseLeave, null);
							addStdText(svg2, null, 'part_dropdown_selected_text', width-partDescriptorMaxNameWidth-295, 22.5, '12px', 0, partDropDownSelected);


							nodeSizeSetupOutput = nodeSizeSetup(partDropDownSelected),
							partDescriptiveValues = nodeSizeSetupOutput[0],
							maxDomain = nodeSizeSetupOutput[1],
							stdNullRadiusSize = nodeSizeSetupOutput[2];

							// base value that will be used to calculate the values appended to the arrays above.
							// including linkNodeSize inside of addedMarginSize.
							linkNodeSize = 10,
							nodeMarginCalculationOutput = nodeSizeCalculation(maxDomain, linkNodeSize, partDescriptiveValues, stdNullRadiusSize),
							nodeMargins = nodeMarginCalculationOutput[0],
							nodeIndices = nodeMarginCalculationOutput[1];

							svg3.selectAll('.nodes').transition().duration(3000)
									.attr('r', function(d, i) { return nodeMargins['size'][i] });

							svg3.selectAll('.node_names').transition().duration(3000)
									.attr('dx', function(d, i) { return nodeMargins['horizontal_name_shift'][i] })
									.attr('dy', function(d, i) { return nodeMargins['vertical_name_shift'][i] });

							svg3.selectAll('.node_size_warning')
									.attr('dx', function(d, i) { return nodeMargins['size'][i] * -1.5 })
						      .attr('dy', function(d, i) { return nodeMargins['size'][i] * 0.75 })
									.style('opacity', function(d, i) {
										if ( isNaN(parseFloat(partDescriptiveValues[i])) )
											{ return 1 }
										else
										{ return 0 }
									});

							// if (!d3.event.active) graphLayout.alphaTarget(0.3).restart();

							graphLayout = d3.forceSimulation(graph.nodes.concat(linkNodes))
									.force('charge', d3.forceManyBody().strength(-3000))
							    .force('center', d3.forceCenter(width/2, height/2))
							    .force('x', d3.forceX(width/2).strength(1))
							    .force('y', d3.forceY(height/2).strength(1))
							    .force('link', d3.forceLink(graph.links).id(function(d) { return parseInt(d.id) }).distance(function(d) { return Math.max((((nodeMargins['size'][nodeIndices[d.source.participant]] + nodeMargins['size'][nodeIndices[d.target.participant]])) * 2), 75) }).strength(1))
							    .on('tick', ticked);
					};

				var fillNullDescriptors = function(descriptive_fields, descriptor_name_lengths, grouping) {
					// creating a value for a default link descriptor
					if ( descriptive_fields[grouping].length==0 )
					{ descriptiveFields[grouping].push('None');
						descriptor_name_lengths[grouping].push(getTextWidth(svg2, 'None', '12px'));
					}

					var dropDownSelected = descriptive_fields[grouping][0],
							descriptorMaxNameWidth = descriptor_name_lengths[grouping].reduce(function(a, b) { return Math.max(a, b) });

					return 	[dropDownSelected, descriptorMaxNameWidth]
				};

				var linkNullDescriptorOutput = fillNullDescriptors(descriptiveFields, descriptorNameLengths, 'dyadic'),
						linkDropDownSelected = linkNullDescriptorOutput[0],
						linkDescriptorMaxNameWidth = linkNullDescriptorOutput[1];

				addStdRect(svg2, null, 'link_dropdown_selected_rect', width-linkDescriptorMaxNameWidth-10, 1, linkDescriptorMaxNameWidth+10, 30, 'black', 1, null, 'transparent', null, linkMenuMouseOver, linkMenuMouseLeave, null);
				addStdText(svg2, null, 'link_dropdown_selected_text', width-linkDescriptorMaxNameWidth-5, 22.5, '12px', 0, linkDropDownSelected);

				var partNullDescriptorOutput = fillNullDescriptors(descriptiveFields, descriptorNameLengths, 'participant'),
						partDropDownSelected = partNullDescriptorOutput[0],
						partDescriptorMaxNameWidth = partNullDescriptorOutput[1];

				addStdRect(svg2, null, 'part_dropdown_selected_rect', width-partDescriptorMaxNameWidth-300, 1, partDescriptorMaxNameWidth+10, 30, 'black', 1, null, 'transparent', null, partMenuMouseOver, partMenuMouseLeave, null);
				addStdText(svg2, null, 'part_dropdown_selected_text', width-partDescriptorMaxNameWidth-295, 22.5, '12px', 0, partDropDownSelected);

				// new code section: start of code for svg3
				var color = d3.scaleLinear().domain([1,2]).range(['lightgreen', 'violet']);

				var linkNodes = [];

				graph.links.forEach(function(link) {

					linkNodes.push({
						source: graph.nodes[link.source],
						target: graph.nodes[link.target]
					});
				});

				var nodeSizeSetup = function (sizeField) {

					var	partDescriptiveValues = [],
							// this will become the sum of all inputs to the radius function
							maxDomain = 0,
							// this will be used to count the total nodes with null radius sizes.
							nullRadiusNodes = 0;

					// first defining the data that will ifnnfluence how the svg is defnined
					graph.nodes.forEach(function(d) {
							// determining totalCasualties across all countries as maxRadius.
							// this will make larger numbers proportional to the total across all countries.
							if ( isNaN(+d[sizeField]) )
							 { nullRadiusNodes+=1; }
							else
							{ maxDomain+=parseFloat(d[sizeField]); }

							partDescriptiveValues.push(+d[sizeField]);
					});

					var totalNodes = partDescriptiveValues.length;
					// console.log('nullRadiusNodes: ', nullRadiusNodes);
					// console.log('totalNodes: ', totalNodes);
					if ( nullRadiusNodes!=totalNodes )
					// stdNullRadiusSize is the average of non-null inputs for node size
					{ stdNullRadiusSize = (maxDomain/(totalNodes - nullRadiusNodes));
						maxDomain = maxDomain + (stdNullRadiusSize * nullRadiusNodes); }
					else { maxDomain = 2;
								stdNullRadiusSize = maxDomain/totalNodes; }

					return [partDescriptiveValues, maxDomain, stdNullRadiusSize];
				};

				var nodeSizeCalculation = function (maxDomain, linkNodeSize, partDescriptiveValues, stdNullRadiusSize) {

					var maxRadius = 150,
							radius = d3.scaleLinear()
																.domain([0, maxDomain])
																.range([1, maxRadius]);

					var addedMarginSize = 2.5 + linkNodeSize,
							// dic for size of all the participant nodes, and size needed around them according to borders and text adjustments
							nodeMargins = {
								'name': [],
								'size': [],
								// array for vertical distance each text label needs to be shifted
								'vertical_name_shift': [],
								'name_fits_in_node': [],
								// array for horizontal distance each text label needs to be shifted
								'horizontal_name_shift': [],
								// array for the lengths of the names of all the participant names on the screen
								'name_lengths': [],
								// creating four arrays to define values that will prevent any nodes, lines, or text from leaving/being cut off from the svg3.
								'added_top_margin': [],
								'added_bottom_margin': [],
								'added_left_margin': [],
								'added_right_margin': []
							},
							nodeIndices = {},
							// creating a dummy svg so that the gettextwidth function can be used before any 'real' svgs are defined
							svgDummy = d3.select('#war_menu').append('svg').attr('width', 0).attr('height', 0);

					// now going through the iterations that needed radius to already be defined
					graph.nodes.forEach(function(d, i) {
							// adding each participant to the array of indices
							// this will be used to indice through the nodeMargins by participant
							nodeIndices[d.participant] = i;
							// determining totalCasualties across all countries as maxRadius.
							// this will make larger numbers proportional to the total across all countries.
							if ( isNaN(partDescriptiveValues[i]) )
							 { currentRadiusSize = radius(stdNullRadiusSize); }
							else
							 { currentRadiusSize = radius(partDescriptiveValues[i]); }
							nodeMargins['size'].push(currentRadiusSize),
							nodeMargins['name'].push(d.participant),
							currentNameLength = getTextWidth(svgDummy, d.participant, '15px'),
							currentNameLengthHalf = currentNameLength/2,
							nodeMargins['name_lengths'].push(currentNameLength),
							currentVerticalShift = nameVerticalShift(svgDummy, currentRadiusSize, d.participant, '12px'),
							currentHorizontalShift = nameHorizontalShift(svgDummy, currentRadiusSize, d.participant, '12px'),
							nodeMargins['vertical_name_shift'].push(currentVerticalShift),
							nodeMargins['name_fits_in_node'].push(nameFitsInNode(svgDummy, currentRadiusSize, d.participant, '12px')),
							nodeMargins['horizontal_name_shift'].push(currentHorizontalShift),
							// the node, plus vertical shift, plus a little extra (and a little extra more to account for text itself
							// text is not a factor since it is always below or inside the node
							nodeMargins['added_top_margin'].push(currentRadiusSize + currentVerticalShift + addedMarginSize),
							// the node, plus the added space for the name shift, plus a little extra
							nodeMargins['added_bottom_margin'].push(currentRadiusSize + currentVerticalShift + addedMarginSize);
							if ( currentHorizontalShift > 0 )
							// the distance from the middle of the node to the left, not including the radius because that's overlap
							{ nodeMargins['added_left_margin'].push(currentNameLengthHalf + currentHorizontalShift + addedMarginSize); }
							else
							// the node, plus half the length of the name on the screen, plus a little extra
							// text is not a factor on the left if the above does not apply
							{ nodeMargins['added_left_margin'].push(currentRadiusSize + addedMarginSize); }
							if ( currentHorizontalShift > 0 )
							// half the length of the name on the screen, plus the amount shifted to the right, plus a little extra
							 { nodeMargins['added_right_margin'].push(currentNameLengthHalf + currentHorizontalShift + addedMarginSize); }
							else
							// the node plus a little extra
							// don't need to adjust for the name if it is inside the node
							{ nodeMargins['added_right_margin'].push(currentRadiusSize + addedMarginSize); }
					});
					return [nodeMargins, nodeIndices];
				};

				var nodeSizeSetupOutput = nodeSizeSetup('battle_deaths'),
						partDescriptiveValues = nodeSizeSetupOutput[0],
						maxDomain = nodeSizeSetupOutput[1],
						stdNullRadiusSize = nodeSizeSetupOutput[2];

				// base value that will be used to calculate the values appended to the arrays above.
				// including linkNodeSize inside of addedMarginSize.
				var linkNodeSize = 10,
						nodeMarginCalculationOutput = nodeSizeCalculation(maxDomain, linkNodeSize, partDescriptiveValues, stdNullRadiusSize),
						nodeMargins = nodeMarginCalculationOutput[0],
						nodeIndices = nodeMarginCalculationOutput[1];

				// append the svg3 object to the body of the page
				var svg3 = d3.select('#war_network_analysis')
						.append('svg')
						  .attr('width', width)
						  .attr('height', height)
						  .attr('transform',
						        'translate(' + margin.left + ',' + margin.top + ')');

				var svg3BodyMO = function(d) {

					svg2.selectAll('.link_descriptor_dropdowns').remove();
					svg2.select('#link_dropdown_selected_text').style('opacity', 1);

					svg2.selectAll('.part_descriptor_dropdowns').remove();
					svg2.select('#part_dropdown_selected_text').style('opacity', 1);
				};

				addStdRect(svg3, null, null, 0, 0, width, height, 'black', 1, null, 'transparent', null, svg3BodyMO, null, null);

				var graphLayout = d3.forceSimulation(graph.nodes.concat(linkNodes))
				    .force('charge', d3.forceManyBody().strength(-3000))
				    .force('center', d3.forceCenter(width/2, height/2))
				    .force('x', d3.forceX(width/2).strength(1))
				    .force('y', d3.forceY(height/2).strength(1))
				    .force('link', d3.forceLink(graph.links).id(function(d) { return parseInt(d.id) }).distance(function(d) { return Math.max((((nodeMargins['size'][nodeIndices[d.source.participant]] + nodeMargins['size'][nodeIndices[d.target.participant]])) * 2), 75) }).strength(1))
				    .on('tick', ticked);

				var linkStrokeWidth = 1;

				var link = svg3.selectAll().append('g')
						.data(graph.links)
						.enter();

		    link.append('line')
						.attr('class', 'link')
				    .attr('stroke', '#aaa')
				    .attr('stroke-width', linkStrokeWidth);

				// creating inputs for the function to check whether each node is part of the selected node's primary network.
				// I have no idea why but this line doesn't work if I move it anywhere else.
				var firstDegreeLinks = [];

				graph.links.forEach(function(d) {
				    firstDegreeLinks[d.source.index + '-' + d.target.index] = true;
				    firstDegreeLinks[d.target.index + '-' + d.source.index] = true;
				});

				// overlaying lines of different styles
				// this will be used to accent interactions between nodes
				// identifying all dyads that shouldn't be included with a class assignment.
				// these will be removed immediately after creation.
				var linkDashStrokeWidth = 2;

				link.append('line')
						.attr('class', 'link_dash')
						.attr('stroke', 'blue')
						.attr('stroke', function(d) {
							if ( linkDescriptorValues[d.index] <= 0 )
							{ return 'transparent' }
							else
							{ return 'blue' }
						})
						.attr('stroke-dasharray', ('2.5, 12'))
						.attr('stroke-dashoffset', -7.5)
						.attr('stroke-width', linkDashStrokeWidth);

				// appending invisible circle to decrease possibility of overlap
				var linkNode = svg3.selectAll()
			      .data(linkNodes)
					.enter().append('circle')
						.attr('fill', 'pink')
						.attr('opacity', 0)
			      .attr('r', linkNodeSize);

				var node = svg3.selectAll()
			      .data(graph.nodes)
			    .enter().append('g')
						.on('mouseover', nodeMouseOver)
						.on('mouseleave', nodeMouseLeave)
						.call(d3.drag()
				        .on('start', dragstarted)
				        .on('drag', dragged)
				        .on('end', dragended));

				node.append('circle')
					.attr('class', 'nodes')
					.attr('stroke', 'black')
					.attr('stroke-width', 1)
		      .attr('r', function(d, i) { return nodeMargins['size'][i] })
					// .attr('opacity', 0.5)
		      .style('fill', function(d) {
						if ( parseInt(d.side)==3 )
						// returning a color in the middle of the spectrum if the side is 3
						// this would mean they were on side 1 and side 2 (1 + 2)
						{ return color(1.5) }
						else
						{ return color(parseInt(d.side)) }
					});

				node.append('text')
						.attr('class', 'node_names')
						.attr('id', function(d, i) { return 'label_' + i })
						.attr('dx', function(d, i) { return nodeMargins['horizontal_name_shift'][i] })
			      .attr('dy', function(d, i) { return nodeMargins['vertical_name_shift'][i] })
						.attr('font-size', '12px')
			      .attr('text-anchor', 'middle')
			      .text(function(d)
						{ return d.participant; });

				node.append('text')
						.attr('class', 'node_size_warning')
						.attr('dx', function(d, i) { return nodeMargins['size'][i] * -1.5 })
			      .attr('dy', function(d, i) { return nodeMargins['size'][i] * 0.75 })
						.attr('font-size', '15px')
			      .attr('text-anchor', 'middle')
						.style('opacity', function(d, i) {
							if ( isNaN(parseFloat(partDescriptiveValues[i])) )
								{ return 1 }
							else
							{ return 0 }
						})
			      .text('?');

				function firstDegreeCheck(a, b) {

						return a==b || firstDegreeLinks[a + '-' + b]
				};

				function nodeMouseOverForLinks(linkInput, indexInput, strokeWidthInput) {
					// accenting first degree links for that node
					// making all links not associated with that node's first degree network opaque
					svg3.selectAll(linkInput)
							.style('opacity', function(o) {
								// make non-neighbor links opaque
								if ( o.source.index==indexInput || o.target.index==indexInput )
									{ return 1 }
								else
								{ return 0.15 }
							})
							.style('stroke-width', function(o) {
								// increase stroke width for neighbor links
								if ( o.source.index==indexInput || o.target.index==indexInput )
									{ return strokeWidthInput }
							});
				}

				function nodeMouseOver(d) {

						d3.select(this).style('cursor', 'pointer');
						var eventTargetIndex = d3.select(d3.event.target).datum().index;
						// accenting first degree network for that node
						// making all objects not associated with that node's first degree network opaque
						node.style('opacity', function(o) {
							// not a neighbor node, make it opaque
							if ( firstDegreeCheck(eventTargetIndex, o.index)!=1 )
								{ return 0.15 }
						});
						// // not sure why line below did not work.
						// .style('stroke-width', function(o) {
						// 	// neighbor node, increase stroke width
						// 	if ( firstDegreeCheck(index, o.index)==1 )
						// 		return 10;
						// 		// return 2;
						// });

						nodeMouseOverForLinks('.link', eventTargetIndex, linkStrokeWidth + 0.5);
						nodeMouseOverForLinks('.link_dash', eventTargetIndex, linkDashStrokeWidth + 1.5);
				};

				function nodeMouseLeave() {
						// reverting all changes in mouseover upon mouseleave
					 // nodeLabel.attr('display', 'block');
					 node.style('opacity', 1);
					 svg3.selectAll('.link').style('opacity', 1).style('stroke-width', linkStrokeWidth);
					 svg3.selectAll('.link_dash').style('opacity', 1).style('stroke-width', linkDashStrokeWidth);
				};

			  function ticked() {

					node.each(function(d, i) {

						if ( nodeMargins['name_fits_in_node'][i]==false )
						{
							// need to add two additional if statements,
							// one for if the label is at max y, and one for if the label is at min y.
							// some sort of randomization will need to determine what to do in these cases to prevent overlap.
							if ( d.x < width * 0.5 && d.y < height * 0.5 )
							{ d3.select('#label_' + i)
									.transition().duration(100)
									.attr('dx', nodeMargins['horizontal_name_shift'][i] * -1)
									.attr('dy', nodeMargins['vertical_name_shift'][i] * -1);
						}
							else if ( d.x >= width * 0.5 && d.y < height * 0.5 )
							{ d3.select('#label_' + i)
									.transition().duration(100)
									.attr('dx', nodeMargins['horizontal_name_shift'][i])
									.attr('dy', nodeMargins['vertical_name_shift'][i] * -1);
						}
							else if ( d.x < width * 0.5 && d.y >= height * 0.5 )
							{ d3.select('#label_' + i)
									.transition().duration(100)
									.attr('dx', nodeMargins['horizontal_name_shift'][i] * -1)
									.attr('dy', nodeMargins['vertical_name_shift'][i]);
						}
							else
							//* (d.x/(width * 0.5)); })// * (d.y/(height * 0.5)); })
							{ d3.select('#label_' + i)
								.transition().duration(100)
								.attr('dx', nodeMargins['horizontal_name_shift'][i])
								.attr('dy', nodeMargins['vertical_name_shift'][i]);
						}
					}
				 });

					// transform statement below prevents nodes from going beyond the dimensions of the svg3.
					// boundaries are then limited even further since when they get close to the edge of the svg3, items like text begin to be cut off.
					// needs to also be adjusted for the participant name label since this could be positioned below the node
					// text adjustments are not needed for anything above the node because the text is always below (or inside) the node
					// includes transformation for nodes and the text itself
					node.attr('transform', function(d, i) { return 'translate(' + Math.max(nodeMargins['added_left_margin'][i], Math.min(width - nodeMargins['added_right_margin'][i], d.x)) + ',' + Math.max(nodeMargins['added_top_margin'][i], Math.min(height - nodeMargins['added_bottom_margin'][i], d.y)) + ')' })

					linkNode.attr('cx', function(d) { return d.x = (Math.max(nodeMargins['added_left_margin'][nodeIndices[d.source.participant]], Math.min(width - nodeMargins['added_right_margin'][nodeIndices[d.source.participant]], d.source.x)) + Math.max(nodeMargins['added_left_margin'][nodeIndices[d.target.participant]], Math.min(width - nodeMargins['added_left_margin'][nodeIndices[d.target.participant]], d.target.x))) * 0.5 })
									.attr('cy', function(d) { return d.y = (Math.max(nodeMargins['added_top_margin'][nodeIndices[d.source.participant]], Math.min(height - nodeMargins['added_bottom_margin'][nodeIndices[d.source.participant]], d.source.y)) + Math.max(nodeMargins['added_top_margin'][nodeIndices[d.target.participant]], Math.min(height - nodeMargins['added_bottom_margin'][nodeIndices[d.target.participant]], d.target.y))) * 0.5 });

					svg3.selectAll('.link,.link_dash')
							.attr('x1', function(d) { return Math.max(nodeMargins['added_left_margin'][nodeIndices[d.source.participant]], Math.min(width - nodeMargins['added_right_margin'][nodeIndices[d.source.participant]], d.source.x)) })
			        .attr('y1', function(d) { return Math.max(nodeMargins['added_top_margin'][nodeIndices[d.source.participant]], Math.min(height - nodeMargins['added_bottom_margin'][nodeIndices[d.source.participant]], d.source.y)) })
			        .attr('x2', function(d) { return Math.max(nodeMargins['added_left_margin'][nodeIndices[d.target.participant]], Math.min(width - nodeMargins['added_left_margin'][nodeIndices[d.target.participant]], d.target.x)) })
			        .attr('y2', function(d) { return Math.max(nodeMargins['added_top_margin'][nodeIndices[d.target.participant]], Math.min(height - nodeMargins['added_bottom_margin'][nodeIndices[d.target.participant]], d.target.y)) })
				  }

				function dragstarted(d) {
						// need to figure out why cursor is being interfered when drag has not ended
						d3.select(this).style('cursor', 'grab');
				    d3.event.sourceEvent.stopPropagation();
				    if (!d3.event.active) graphLayout.alphaTarget(0.3).restart();
				    d.fx = d.x;
				    d.fy = d.y;
				}

				function dragged(d) {
						// need to figure out why cursor is being interfered when drag has not ended
						d3.select(this).style('cursor', 'grab');
				    d.fx = d3.event.x;
				    d.fy = d3.event.y;
				}

				function dragended(d) {
						// need to figure out why cursor is being interfered when drag has not ended
						d3.select(this).style('cursor', 'pointer');
				    if (!d3.event.active) graphLayout.alphaTarget(0);
				    d.fx = null;
				    d.fy = null;
				}
				});
		}})
		</script>
	</body>
</html>
