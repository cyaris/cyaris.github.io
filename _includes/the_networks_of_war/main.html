<!-- <!DOCTYPE html> -->
<html>
	<head>
		<title>The Networks of War</title>
	 <!-- subtitle: Network Analysis Between Countries at War  -->
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<style>

		@media (max-width:660px){
	      #war_network_analysis {
						display: none;
	      }
				#hover_statistics {
						display: none;
	      }
				#message {
						display: none;
	      }
			}

		@media (min-width:660px){
			#hidden_project_explained {
				display: none;
	    }
	  }

		svg {
			border: 1px solid #000;
		}

		.node text {
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
		}

		</style>
	</head>
	<body>
		<!-- Load d3.js -->
		<!-- <script src="https://d3js.org/d3.v4.min.js"></script> -->

		<script src="//d3js.org/d3.v3.min.js"></script>
		<div id="hidden_project_explained" align="left" style="margin-bottom:15px;">
			<p>While I'm flattered you came to check out my project, it has several interactive features that work best on desktop. So, grab a computer and come back soon!</p>
		</div>
		<div id="message">
		  <p>Hey there! I'm developing a tool to analyze the networks between countries at war, using data provided by <a href="https://correlatesofwar.org/" target="_blank">The Correlates of War Project</a>. This project is currently in progress. Stay tuned soon for more updates.</p>
		</div>
		<!-- Create a div where the graph will take place -->
		<div id="war_network_analysis" align="center" style="margin-bottom:15px;"></div>
		<div id="hover_statistics" align="center" style="margin-bottom:15px;"></div>
		<script>

		var warPageURL = window.location.href,
				warPageType = warPageURL.split("the_networks_of_war_")[1].split("s/")[0];

		//Read the data
		d3.csv("../assets/the_networks_of_war/war_file_list.csv", function(data) {

			file_list = [];
			data.forEach(function(d) {
				var fileWarType = d.war_type.toLowerCase().replace("-", "_").replace(" ", "_");
				if ( warPageType == fileWarType )
				{ file_list.push(d.file_name); }
			});

		d3.json("../assets/the_networks_of_war/json_files_by_war/" + file_list[Math.floor(Math.random() * file_list.length)], function(error, graph) {

			function getTextWidth(textInput) {

				// obtaining length of any textinput (based on default font size and font family)
				var textWidthArray = [];

				svg1.append("g")
						    .selectAll('.dummyText')
						    .data([textInput])
						    .enter()
						    .append("text")
									.attr("pointer-events", "none")
									.attr("font-family", "sans-serif")
							    .attr("font-size", "10px")
							    .text(function(d) { return d; })
							    .each(function(d,i) {
							        var thisWidth = this.getComputedTextLength();
							        textWidthArray.push(thisWidth);
							        this.remove();
				    });

				{
					var textWidth = textWidthArray.reduce((a, b) => a + b, 0);
					return textWidth;
				}
			};

			function nameVerticalShift(nodeRadius, countryName) {
				// adjusting text position when it does not fit inside the node
				if ( nodeRadius * 2 < getTextWidth(countryName) + 7.5 )
				{ return nodeRadius + 20 }
				else
				{ return 3.5 };

			}

			function nameHorizontalShift(nodeRadius, countryName) {
				// adjusting text position when it does not fit inside the node
				if ( nameVerticalShift(nodeRadius, countryName) > 3.5 )
				{ return 22.5 }
				else
				{ return 0 };

			}

		  if (error) throw error;

			var sumOfAllRadiusInputs = 0,
					nullBattleDeaths = 0,
					totalNodes = 0;

			var startDateDic = {},
					endDateDic = {},
					startYearDic = {},
					endYearDic = {},
					totalDaysDic = {},
					battleDeathDic = {},
					moneyFlowOutDic = {},
					moneyFlowInDic = {},
					importsDic = {},
					exportsDic = {},
					militaryExpenditureDic = {},
					militaryPersonnelDic = {},
					primEnergyConsumptionDic = {},
					ironSteelProductionDic = {},
					populationDic = {},
					urbanPopulationDic = {},
					cincScoreDic = {};

			var formatDate = d3.time.format("%Y-%m-%d %S:%M:%S");
			// format the data
			graph.nodes.forEach(function(d) {
					// determining totalCasualties across all countries as maxRadius.
					// this will make larger numbers proportional to the total across all countries.
					if ( d.battle_deaths != 'nan' )
					 { sumOfAllRadiusInputs += parseFloat(d.battle_deaths) }
					else { nullBattleDeaths += 1 }
					totalNodes += 1,
					startDateDic[d.country] = formatDate.parse(d.start_date),
					endDateDic[d.country] = formatDate.parse(d.end_date),
					startYearDic[d.country] =+ parseInt(d.start_year),
					endYearDic[d.country] =+ parseInt(d.end_year),
					totalDaysDic[d.country] =+ d.days_at_war,
					battleDeathDic[d.country] =+ d.battle_deaths,
					// totalExpenditureForWarTest += Math.max(parseFloat(d.military_expenditure_x), parseFloat(d.military_expenditure_y)),
					// obtaining greatest value for descriptive statistics between the year the country entered the conflict and the year the country exited the conflict.
					moneyFlowOutDic[d.country] = Math.max(parseFloat(d.money_flow_out_x), parseFloat(d.money_flow_out_y)),
					moneyFlowOutDic[d.country] = Math.max(parseFloat(d.money_flow_out_x), parseFloat(d.money_flow_out_y)),
					moneyFlowInDic[d.country] = Math.max(parseFloat(d.money_flow_in_x), parseFloat(d.money_flow_in_y)),
					importsDic[d.country] = Math.max(parseFloat(d.imports_x), parseFloat(d.imports_y)),
					exportsDic[d.country] = Math.max(parseFloat(d.exports_x), parseFloat(d.exports_y)),
					militaryExpenditureDic[d.country] = Math.max(parseFloat(d.military_expenditure_x), parseFloat(d.military_expenditure_y)),
					militaryPersonnelDic[d.country] = Math.max(parseFloat(d.military_personnel_x) + parseFloat(d.military_personnel_y)),
					primEnergyConsumptionDic[d.country] = Math.max(parseFloat(d.prim_energy_consumption_x) + parseFloat(d.prim_energy_consumption_y)),
					ironSteelProductionDic[d.country] = Math.max(parseFloat(d.iron_steel_production_x) + parseFloat(d.iron_steel_production_y)),
					populationDic[d.country] = Math.max(parseFloat(d.total_population_x) + parseFloat(d.total_population_y)),
					urbanPopulationDic[d.country] = Math.max(parseFloat(d.urban_population_x) + parseFloat(d.urban_population_y)),
					cincScoreDic[d.country] = Math.max(parseFloat(d.cinc_score_x) + parseFloat(d.cinc_score_y));

			});

			console.log("battle deaths: ", battleDeathDic)
			console.log("start dates: ", startDateDic);
			console.log("end dates: ", endDateDic);
			console.log("start years: ", startYearDic);
			console.log("end years: ", endYearDic);
			console.log("total days: ", totalDaysDic);
			console.log("money out: ", moneyFlowOutDic);
			console.log("money in: ", moneyFlowInDic);
			console.log("imports: ", importsDic);
			console.log("exports: ", exportsDic);
			console.log("military expenditure: ", militaryExpenditureDic);
			console.log("military personnel: ", militaryPersonnelDic);
			console.log("prim energey consumption: ", primEnergyConsumptionDic);
			console.log("iron steel production: ", ironSteelProductionDic);
			console.log("population: ", populationDic);
			console.log("urgan population: ", urbanPopulationDic);
			console.log("cinc score: ", cincScoreDic);

			var nullRadiusSize = 0;

			if  ( nullBattleDeaths != totalNodes )
			{ nullRadiusSize = (sumOfAllRadiusInputs/(totalNodes - nullBattleDeaths));
				sumOfAllRadiusInputs = sumOfAllRadiusInputs + (nullRadiusSize * nullBattleDeaths); }
			else { sumOfAllRadiusInputs = 2;
						nullRadiusSize = sumOfAllRadiusInputs/totalNodes; }

			var color = d3.scale.linear().domain([1,2]).range(["lightgreen", "violet"])
					maxRadius = 150,
					radius = d3.scale.linear()
														.domain([0, sumOfAllRadiusInputs])
														.range([1, maxRadius]);

			// set the dimensions and margins of the graph
			var margin = {top: 0, bottom: 15, left: 0, right: 0},
			    width = 750,
			    height = 550;

			// append the svg1 object to the body of the page
			var svg1 = d3.select("#war_network_analysis")
					.append("svg")
					  .attr("width", width)
					  .attr("height", height)
					  .attr("transform",
					        "translate(" + margin.left + "," + margin.top + ")");

			// adding area for descriptive statistics to be activated upon hovering nodes.
			var svg2 = d3.select("#hover_statistics")
					.append("svg")
						.attr("pointer-events", "none")
						.attr("width", width)
						.attr("height", 25)
						.attr("transform",
					        "translate(" + margin.left + "," + margin.top + ")");

					// dic for size of all the country nodes
			var nodeRadiusDic = {},
					// dic for vertical distance each text label needs to be shifted
					nameVerticalShiftDic = {},
					// dic for horizontal distance each text label needs to be shifted
					nameHorizontalShiftDic = {},
					// dict for the lengths of the names of all the country names on the screen
					nameLengthDic = {},
					// creating four dictionaries to define values that will prevent any nodes, lines, or text from leaving/being cut off from the svg1.
					addedTopMargin = {},
					addedBottomMargin = {},
					addedLeftMargin = {},
					addedRightMargin = {},
					// base value that will be used to calculate the dictionaries above
					addedMarginSize = 7.5;

			graph.nodes.forEach(function(d) {

					if ( d.battle_deaths != 'nan' )
					 { nodeRadiusDic[d.country] = radius(parseInt(d.battle_deaths)) }
					else
					 { nodeRadiusDic[d.country] = radius(nullRadiusSize) }
					nameLengthDic[d.country] = getTextWidth(d.country),
					nameVerticalShiftDic[d.country] = nameVerticalShift(nodeRadiusDic[d.country], d.country),
					nameHorizontalShiftDic[d.country] = nameHorizontalShift(nodeRadiusDic[d.country], d.country),
					// the node, plus a little extra
					// text is not a factor since it is always below or inside the node
					addedTopMargin[d.country] = nodeRadiusDic[d.country] + addedMarginSize,
					// the node, plus the added space for the name shift, plus a little extra
					addedBottomMargin[d.country] = nodeRadiusDic[d.country] + addedMarginSize + nameVerticalShiftDic[d.country];
					if ( nameHorizontalShiftDic[d.country] > 0  && ((nameLengthDic[d.country])/2 - nameHorizontalShiftDic[d.country]) > nodeRadiusDic[d.country] )
					// the distance from the middle of the node to the left, minus the radius because that's overlap
					{ addedLeftMargin[d.country] = ((nameLengthDic[d.country]/2) - nameHorizontalShiftDic[d.country]) - nodeRadiusDic[d.country] + addedMarginSize; }
					else
					// the node, plus half the length of the name on the screen, plus a little extra
					// text is not a factor on the left if the above does not apply
					{ addedLeftMargin[d.country] = nodeRadiusDic[d.country] + addedMarginSize; }
					if ( nameHorizontalShiftDic[d.country] > 0 )
					// half the length of the name on the screen, plus the amount shifted to the right, plus a little extra
					 { addedRightMargin[d.country] = addedMarginSize + (nameLengthDic[d.country]/2) + nameHorizontalShiftDic[d.country]; }
					else
					// the node plus a little extra
					// don't need to adjust for the name if it is inside the node
					{ addedRightMargin[d.country] = nodeRadiusDic[d.country] + addedMarginSize; }
			});

			var force = d3.layout.force()
			    .size([width, height])
			    .charge(-500)
					// .friction(0.75)
					.gravity(0.075)
					.linkStrength(0.5)
					.linkDistance(function(d) { return (nodeRadiusDic[d.source.country] + nodeRadiusDic[d.target.country] + (nameLengthDic[d.source.country]/2) + (nameLengthDic[d.target.country]/2) + 50 ); });
					// .linkDistance(height/3);
		  force
		      .nodes(graph.nodes)
		      .links(graph.links)
		      .on("tick", tick)
		      .start();

		  var link = svg1.selectAll()
		      .data(graph.links)
		    	.enter().append("g")

		  link.append("line")
					.attr("stroke", "#696969")
		      .style("stroke-width", function(d) { return (d.lines * 2 - 1) * 2 + "px"; });

		  link.filter(function(d) { return d.lines > 1; })
					.append("line")
					.attr("stroke", "#fff")
					.attr("stroke-width", "2px");

		  var node = svg1.selectAll()
		      .data(graph.nodes)
		    .enter().append("g")
		      .attr("class", "node")
		      .call(force.drag);

		  node.append("circle")
					.attr("stroke", "black")
					.attr("stroke-width", 1)
					// .attr("opacity", 0.5)
		      .attr("r", function(d) { return nodeRadiusDic[d.country]; })
		      .style("fill", function(d) {
						if ( d.side==3 )
						// returning a color in the middle of the spectrum if the side is 3
						// this would mean they were on side 1 and side 2 (1+2)
						{ return color(1.5); }
						else
						{ return color(d.side); }
						});

		  node.append("text")
					.attr("class", "text_labels")
					.attr("dx", function(d) { return nameHorizontalShiftDic[d.country]; })
		      .attr("dy", function(d) { return nameVerticalShiftDic[d.country]; })
					.attr("font-family", "sans-serif")
					.attr("font-size", "10px")
		      .attr("text-anchor", "middle")
		      .text(function(d) { return d.country; });

		  function tick() {
		    svg1.selectAll(".node")
						// transform statement below prevents nodes from going beyond the dimensions of the svg1.
						// boundaries are then limited even further since when they get close to the edge of the svg1, items like text begin to be cut off.
						// needs to also be adjusted for the country name label since this could be positioned below the node
						// text adjustments are not needed for anything above the node because the text is always below (or inside) the node
						.attr("transform", function(d) { return "translate(" + Math.max(addedLeftMargin[d.country], Math.min(width - addedRightMargin[d.country], d.x)) + "," + Math.max(addedTopMargin[d.country], Math.min(height - addedBottomMargin[d.country], d.y)) + ")"; })

		    link.selectAll("line")
						.attr("x1", function(d) { return Math.max(addedLeftMargin[d.source.country], Math.min(width - addedRightMargin[d.source.country], d.source.x)); })
		        .attr("y1", function(d) { return Math.max(addedTopMargin[d.source.country], Math.min(height - addedBottomMargin[d.source.country], d.source.y)); })
		        .attr("x2", function(d) { return Math.max(addedLeftMargin[d.target.country], Math.min(width - addedRightMargin[d.target.country], d.target.x)); })
		        .attr("y2", function(d) { return Math.max(addedTopMargin[d.target.country], Math.min(height - addedBottomMargin[d.target.country], d.target.y)); })
		  }
		});

		//
		// d3.json("../assets/networks_of_war/networks_of_war.json", function(error, graph) {
		//
		//
		// var margin = {top: 0, bottom: 15, left: 0, right: 0},
		//     width = 800,
		//     height = 450;
		//
		// // append the svg1 object to the body of the page
		// var svg1 = d3.select("#war_network_analysis")
		// 		.append("svg1")
		// 		  .attr("width", width)
		// 		  .attr("height", height)
		// 			// .append("g")
		// 		  .attr("transform",
		// 		        "translate(" + margin.left + "," + margin.top + ")");
		//
		// var color = d3.scale.category20(),
		// 		maxRadius = 50,
		// 		radius = d3.scale.linear()
		// 												.domain([0, d3.max(graph.nodes, function(d) { return d.size ; })])
		// 												.range([2.5, maxRadius]);
		//
		// 	var force = d3.layout.force()
		// 	    .charge(-500)
		// 	    .linkDistance(function(d) { return nodeRadiusDic[d.source.country] + nodeRadiusDic[d.target.country] + 30; })
		// 	    .size([width, height]);
		//
		//   var linkNodes = [];
		//
		//   graph.links.forEach(function(link) {
		//     linkNodes.push({
		//       source: graph.nodes[link.source],
		//       target: graph.nodes[link.target]
		//     });
		//   });
		//
		//   force
		//       .nodes(graph.nodes.concat(linkNodes))
		//       .links(graph.links)
		//       .start();
		//
		//   var link = svg1.selectAll(".link")
		//       .data(graph.links)
		//     .enter().append("line")
		//       .attr("class", "link")
		//       .style("stroke-width", function(d) { return Math.sqrt(d.bond); });
		//
		//   var node = svg1.selectAll(".node")
		//       .data(graph.nodes)
		//     .enter().append("circle")
		//       .attr("class", "node")
    //       .attr("r", function(d) { return nodeRadiusDic[d.country]; })
		//       .style("fill", "red")
		//       .call(force.drag);
		//
		//   node.append("title")
		//       .text(function(d) { return d.country; });
		//
		//   var linkNode = svg1.selectAll(".link-node")
		//       .data(linkNodes)
		//     .enter().append("circle")
		//       .attr("class", "link-node")
		//       .attr("r", function(d) { return nodeRadiusDic[d.country]; })
		//       .style("fill", "#ccc");
		//
		//   force.on("tick", function() {
		//     link.attr("x1", function(d) { return d.source.x; })
		//         .attr("y1", function(d) { return d.source.y; })
		//         .attr("x2", function(d) { return d.target.x; })
		//         .attr("y2", function(d) { return d.target.y; });
		//
		//     node.attr("cx", function(d) { return d.x; })
		//         .attr("cy", function(d) { return d.y; });
		//
		//     linkNode.attr("cx", function(d) { return d.x = (d.source.x + d.target.x) * 0.5; })
		//         .attr("cy", function(d) { return d.y = (d.source.y + d.target.y) * 0.5; });
		//   });
		// });
	})
		</script>
	</body>
</html>
