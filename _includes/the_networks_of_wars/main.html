<!-- <!DOCTYPE html> -->
<html>
	<head>
		<title>The Networks of Wars</title>
	 <!-- subtitle: Network Analysis Between Countries at War  -->
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<style>

		@media (max-width:660px){
	      #war_network_analysis {
						display: none;
	      }
				#message {
						display: none;
	      }
			}

		@media (min-width:660px){
			#hidden_project_explained {
				display: none;
	    }
	  }

		svg {
			border: 1px solid #000;
		}

		.node text {
		  font: 10px sans-serif;
		  pointer-events: none;
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
		}

		</style>
	</head>
	<body>
		<!-- Load d3.js -->
		<!-- <script src="https://d3js.org/d3.v4.min.js"></script> -->

		<script src="//d3js.org/d3.v3.min.js"></script>
		<div id="hidden_project_explained" align="left" style="margin-bottom:15px;">
			<p>While I'm flattered you came to check out my project, it has several interactive features that work best on desktop. So, grab a computer and come back soon!</p>
		</div>
		<div id="message">
		  <p>Hey there! I'm developing a tool to analyze the networks between countries at war, using data provided by <a href="https://correlatesofwar.org/" target="_blank">The Correlates of War Project</a>. This project is currently in progress. Stay tuned soon for more updates.</p>
		</div>
		<!-- Create a div where the graph will take place -->
		<div id="war_network_analysis" align="center" style="margin-bottom:15px;"></div>
		<script>

		d3.json("../assets/the_networks_of_wars/the_networks_of_wars.json", function(error, graph) {

			function getTextWidth(textInput) {

				// obtaining length of any textinput (based on default font size and font family)
				var textWidthArray = [];

				svg.append("g")
						    .selectAll('.dummyText')
						    .data([textInput])
						    .enter()
						    .append("text")
									.attr("pointer-events", "none")
									.attr("font-family", "sans-serif")
							    .attr("font-size", "10px")
							    .text(function(d) { return d; })
							    .each(function(d,i) {
							        var thisWidth = this.getComputedTextLength();
							        textWidthArray.push(thisWidth);
							        this.remove();
				    });

				{
					var textWidth = textWidthArray.reduce((a, b) => a + b, 0);
					return textWidth;
				}
			};

			function nameVerticalShift(nodeRadius, countryName) {
				// adjusting text position when it does not fit inside the node
				if ( nodeRadius * 2 < getTextWidth(countryName) + 2.5 )
				{ return nodeRadius + 15 }
				else
				{ return 6.25 };

			}

			// function nameHorizontalShift(nodeRadius, countryName) {
			// 	// adjusting text position when it does not fit inside the node
			// 	if ( nameVerticalShift(nodeRadius, countryName) > 6.25 )
			// 	{ return 20 }
			// 	else
			// 	{ return 0 };
			//
			// }

		  if (error) throw error;

			var totalCasualties = 0;
			// format the data
			graph.nodes.forEach(function(d) {
					// determining totalCasualties across all countries as maxRadius.
					// this will make larger numbers proportional to the total across all countries.
					totalCasualties+=d.size;
			});

			var color = d3.scale.linear().domain([1,2]).range(["lightgreen", "violet"])
					maxRadius = 150,
					radius = d3.scale.linear()
														.domain([0, totalCasualties])
														.range([1, maxRadius]);

			// set the dimensions and margins of the graph
			var margin = {top: 0, bottom: 15, left: 0, right: 0},
			    width = 800,
			    height = 550;

			// append the svg object to the body of the page
			var svg = d3.select("#war_network_analysis")
					.append("svg")
					  .attr("width", width)
					  .attr("height", height)
						// .append("g")
					  .attr("transform",
					        "translate(" + margin.left + "," + margin.top + ")");

					// dic for size of all the country nodes
			var nodeRadiusDic = {},
					// dic for vertical distance each text label needs to be shifted
					nameVerticalShiftDic = {},
					// dic for horizontal distance each text label needs to be shifted
					// nameHorizontalShiftDic = {},
					// dict for the lengths of the names of all the country names on the screen
					nameLengthDic = {},
					// creating four dictionaries to define values that will prevent any nodes, lines, or text from leaving/being cut off from the svg.
					addedTopMargin = {},
					addedBottomMargin = {},
					addedLeftMargin = {},
					addedRightMargin = {},
					// base value that will be used to calculate the dictionaries above
					addedMarginSize = 7.5;

			graph.nodes.forEach(function(d) {
					nodeRadiusSize = radius(d.size),
					nodeRadiusDic[d.country] = nodeRadiusSize,
					nameLengthDic[d.country] = getTextWidth(d.country),
					nameVerticalShiftDic[d.country] = nameVerticalShift(nodeRadiusSize, d.country),
					// nameHorizontalShiftDic[d.country] = nameHorizontalShift(nodeRadiusSize, d.country),
					addedTopMargin[d.country] = nodeRadiusDic[d.country] + addedMarginSize,
					// the node, plus the added space for the name shift, plus a little extra
					addedBottomMargin[d.country]	= nodeRadiusDic[d.country] + addedMarginSize + nameVerticalShiftDic[d.country],
					// the node, plus half the length of the name on the screen, plus a little extra
					// need to improve nameLengthDic[d.country]/2 part of left/right because this shouldn't include the part of overlap with the radius
					// same comment for nameHorizontalShiftDic[d.country]
					addedLeftMargin[d.country] = nodeRadiusDic[d.country] + addedMarginSize + (nameLengthDic[d.country]/2),
					// the node, plus half the length of the name on the screen, plus the amount shifted to the right, plus a little extra
					// commenting out version below with nameHorizontalShiftDic
					// addedRightMargin[d.country] = nodeRadiusDic[d.country] + addedMarginSize + (nameLengthDic[d.country]/2) + nameHorizontalShiftDic[d.country];
					addedRightMargin[d.country] = nodeRadiusDic[d.country] + addedMarginSize + (nameLengthDic[d.country]/2);
			});

			console.log(nodeRadiusDic);
			var force = d3.layout.force()
			    .size([width, height])
			    .charge(-500)
					// .friction(0.75)
					.gravity(0.075)
					.linkStrength(0.5)
					.linkDistance(function(d) { return (nodeRadiusDic[d.source.country] + nodeRadiusDic[d.target.country] + (nameLengthDic[d.source.country]/2) + (nameLengthDic[d.target.country]/2) + 50 ); });
					// .linkDistance(height/3);
		  force
		      .nodes(graph.nodes)
		      .links(graph.links)
		      .on("tick", tick)
		      .start();

		  var link = svg.selectAll()
		      .data(graph.links)
		    	.enter().append("g")
		      	.attr("class", "link");

		  link.append("line")
					.attr("stroke", "#696969")
		      .style("stroke-width", function(d) { return (d.lines * 2 - 1) * 2 + "px"; });

		  link.filter(function(d) { return d.lines > 1; })
					.append("line")
					.attr("stroke", "#fff")
					.attr("stroke-width", "2px")
		      .attr("class", "separator");

		  var node = svg.selectAll()
		      .data(graph.nodes)
		    .enter().append("g")
		      .attr("class", "node")
		      .call(force.drag);

		  node.append("circle")
					.attr("stroke", "black")
					.attr("stroke-width", 1)
					// .attr("opacity", 0.5)
		      .attr("r", function(d) { return nodeRadiusDic[d.country]; })
		      .style("fill", function(d) { return color(d.side); });

		  node.append("text")
					.attr("class", "country_text")
					// .attr("dx", function(d) { return nameHorizontalShiftDic[d.country]; })
		      .attr("dy", function(d) { return nameVerticalShiftDic[d.country]; })
		      .attr("text-anchor", "middle")
					// .attr("alignment-baseline", "hanging")
		      .text(function(d) { return d.country; })
					.attr("pointer-events", "none");

		  function tick() {

		    svg.selectAll(".node")
						// transform statement below prevents nodes from going beyond the dimensions of the svg.
						// boundaries are then limited even further since when they get close to the edge of the svg, items like text begin to be cut off.
						// needs to also be adjusted for the country name label since this could be positioned below the node
						// text adjustments are not needed for anything above the node because the text is always below (or inside) the node
						.attr("transform", function(d) { return "translate(" + Math.max(addedLeftMargin[d.country], Math.min(width - addedRightMargin[d.country], d.x)) + "," + Math.max(addedTopMargin[d.country], Math.min(height - addedBottomMargin[d.country], d.y)) + ")"; })
		    link.selectAll("line")
						.attr("x1", function(d) { return Math.max(addedLeftMargin[d.source.country], Math.min(width - addedRightMargin[d.source.country], d.source.x)); })
		        .attr("y1", function(d) { return Math.max(addedTopMargin[d.source.country], Math.min(height - addedBottomMargin[d.source.country], d.source.y)); })
		        .attr("x2", function(d) { return Math.max(addedLeftMargin[d.target.country], Math.min(width - addedRightMargin[d.target.country], d.target.x)); })
		        .attr("y2", function(d) { return Math.max(addedTopMargin[d.target.country], Math.min(height - addedBottomMargin[d.target.country], d.target.y)); })
		  }
		});

		//
		// d3.json("../assets/networks_of_wars/networks_of_wars.json", function(error, graph) {
		//
		//
		// var margin = {top: 0, bottom: 15, left: 0, right: 0},
		//     width = 800,
		//     height = 450;
		//
		// // append the svg object to the body of the page
		// var svg = d3.select("#war_network_analysis")
		// 		.append("svg")
		// 		  .attr("width", width)
		// 		  .attr("height", height)
		// 			// .append("g")
		// 		  .attr("transform",
		// 		        "translate(" + margin.left + "," + margin.top + ")");
		//
		// var color = d3.scale.category20(),
		// 		maxRadius = 50,
		// 		radius = d3.scale.linear()
		// 												.domain([0, d3.max(graph.nodes, function(d) { return d.size ; })])
		// 												.range([2.5, maxRadius]);
		//
		// 	var force = d3.layout.force()
		// 	    .charge(-500)
		// 	    .linkDistance(function(d) { return nodeRadiusDic[d.source.country] + nodeRadiusDic[d.target.country] + 30; })
		// 	    .size([width, height]);
		//
		//   var linkNodes = [];
		//
		//   graph.links.forEach(function(link) {
		//     linkNodes.push({
		//       source: graph.nodes[link.source],
		//       target: graph.nodes[link.target]
		//     });
		//   });
		//
		//   force
		//       .nodes(graph.nodes.concat(linkNodes))
		//       .links(graph.links)
		//       .start();
		//
		//   var link = svg.selectAll(".link")
		//       .data(graph.links)
		//     .enter().append("line")
		//       .attr("class", "link")
		//       .style("stroke-width", function(d) { return Math.sqrt(d.bond); });
		//
		//   var node = svg.selectAll(".node")
		//       .data(graph.nodes)
		//     .enter().append("circle")
		//       .attr("class", "node")
    //       .attr("r", function(d) { return nodeRadiusDic[d.country]; })
		//       .style("fill", "red")
		//       .call(force.drag);
		//
		//   node.append("title")
		//       .text(function(d) { return d.country; });
		//
		//   var linkNode = svg.selectAll(".link-node")
		//       .data(linkNodes)
		//     .enter().append("circle")
		//       .attr("class", "link-node")
		//       .attr("r", function(d) { return nodeRadiusDic[d.country]; })
		//       .style("fill", "#ccc");
		//
		//   force.on("tick", function() {
		//     link.attr("x1", function(d) { return d.source.x; })
		//         .attr("y1", function(d) { return d.source.y; })
		//         .attr("x2", function(d) { return d.target.x; })
		//         .attr("y2", function(d) { return d.target.y; });
		//
		//     node.attr("cx", function(d) { return d.x; })
		//         .attr("cy", function(d) { return d.y; });
		//
		//     linkNode.attr("cx", function(d) { return d.x = (d.source.x + d.target.x) * 0.5; })
		//         .attr("cy", function(d) { return d.y = (d.source.y + d.target.y) * 0.5; });
		//   });
		// });

		</script>
	</body>
</html>
