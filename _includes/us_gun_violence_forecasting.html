<!-- <!DOCTYPE html> -->
<html>
	<head>
		<title>US Gun Violence Forecasting</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<style>

		svg {
			border: 1px solid #000;
		}

		.line {
		  fill: none;
		  stroke-width: 2px;
		}

		svg text {
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
			pointer-events: none;
		}

		</style>
	</head>
	<body>
		<!-- <script>

		function lvBtnClick() {
		  var change = document.getElementById("lvRescaleBtn");
		  if (change.innerHTML == "Rescale without<br>Las Vegas Shooting")
			{ yMax = allObs[]; change.innerHTML = "Rescale with<br>Las Vegas Shooting"; }
			else
			{ yMax = allObs[1]; change.innerHTML = "Rescale without<br>Las Vegas Shooting"; }
		}

		</script> -->
		<!-- <div id="lvRescale" style="margin-bottom:10px">
		    <button id="lvRescaleBtn" onClick="lvBtnClick()">Rescale without<br>Las Vegas Shooting</button>
		</div> -->
		<!-- Load d3.js -->
		<script src="https://d3js.org/d3.v4.min.js"></script>
		<!-- Load color palettes -->
		<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
		<!-- Create a div where the graph will take place -->
		<div id="las_vegas_button" align="left"  style="margin-bottom:30;"></div>
		<div id="line_graph" align="center"  style="margin-bottom:40px;"></div>
		<script>
			// set the dimensions and margins of the graph
			var margin = {top: 20, right: 20, bottom: 35, left: 40},
			    width = 750 - margin.left - margin.right,
			    height = 425 - margin.top - margin.bottom;
			// set the dimensions of the margin rects
			var marginRectDic = {
						0: {"x": margin.left * -1, "y": 0,
						"width": margin.left, "height": height},
						1: {"x": width, "y": 0,
						"width": margin.right, "height": height},
						2: {"x": margin.left * -1, "y": margin.top * -1,
						"width": width + margin.left + margin.right, "height": margin.top},
						3: {"x": margin.left * -1, "y": height,
						"width": width + margin.left + margin.right, "height": margin.bottom},
					},
					marginRectDicKeys = Object.keys(marginRectDic);
			// append the svg object to the body of the page
			var svg = d3.select("#line_graph")
					.append("svg")
					  .attr("width", width + margin.left + margin.right)
					  .attr("height", height + margin.top + margin.bottom)
					.append("g")
					  .attr("transform",
					        "translate(" + margin.left + "," + margin.top + ")");
			// parse the date / time
			var parseTime = d3.timeParse("%Y-%m-%d"),
			// set the ranges
					x = d3.scaleTime().range([0, width]),
					y = d3.scaleLinear().range([height, 0]);

			var mouseover = function(d) {
				d3.select(this)
					.style("stroke", "black")
					.style("stroke-width", 3)
					.style("cursor", "pointer");
			};

			var mouseLeave = function(d) {
				d3.select(this)
					.style("stroke", "transparent")
					.style("stroke-width", 0);
			};

			d3.csv("../assets/us_harmed_victim_forecast_data.csv", function(data) {
			var numRows = data.length,
					minYear = d3.min(data, function(d) { return d.year }),
					maxYear = d3.max(data, function(d) { return d.year }),
					numYears = maxYear - minYear,
					obsMaxYear = [],
					allDates = [],
					allObs = [],
					nydDic = {},
					yearIndex = [],
					allYears = [],
					obsPerYearDic = {};
			// format the data
			data.forEach(function(d) {
					d.date = parseTime(d.date);
					d.index = +d.index;
					if ( d.nyd!=null && d.nyd!='' ) {
						nydDic[d.nyd] = d.index
					};
					d.num_harmed = +d.num_harmed;
					allObs.push(d.num_harmed);
					allDates.push(d.date);
					d.year = +d.year;
					d.non_observation = +d.non_observation;
			});

			for (var i = 1; i <= numYears; i++) {
					yearIndex.push(Number(i));
			};

			for ( var i = minYear; i <= maxYear; i++ ) {
					allYears.push(Number(i));
					numDaysCount = 0;
					data.forEach(function(d) {
						if ( d.year==i )
						{ numDaysCount+=1; }
						if ( d.year==i && d.non_observation!=1 )
						{ obsMaxYear.push(Number(i)); }
					});
					obsPerYearDic[i] = numDaysCount;
			};

			var nydKeys = Object.keys(nydDic),
					obsMaxYear = d3.max(obsMaxYear),
					allObs = allObs.sort(function(a,b){return b-a}),
					maxOb = d3.max(allObs),
					yMax = maxOb;

			var w = 125,
					h = 40,
					lvText = "without";
			// append the svg object to the body of the page
			var svg2 = d3.select("#las_vegas_button")
					.append("svg")
					  .attr("width", w+4.5)
					  .attr("height", h+4.5)
						.style("cursor", "pointer");

			svg2.append("rect")
					.attr("x", 1.5)
					.attr("y", 1.5)
					// .attr("rx", 4)
					// .attr("ry", 4)
					.attr("width", w)
					.attr("height", h)
					.style("fill", "transparent")
					.style("stroke-width", 0)
				.on("mouseover", mouseover)
				.on("mouseleave", mouseLeave)
				.on("click", function() {
					if (yMax==maxOb)
					{ yMax = allObs[1];
						console.log(yMax);
						svg2.append("rect")
								.attr("pointer-events", "none")
								.attr("x", 80)
								.attr("y", 5)
								.attr("rx", 4)
								.attr("ry", 4)
								.attr("width", w/4)
								.attr("height", h/2.5)
								.style("fill", "white");
						createRect(yMax);
						updateGraph(yMax, 'red', obsMaxYear);
				}
					else
					{ yMax=maxOb;
						console.log(yMax);
						svg2.append("text")
							 .attr("pointer-events", "none")
							 .attr("x", 80)
							 .attr("y", 17.5)
							 .text("out")
								 .style("font-size", "12px")
								 .style("fill", "black");
						createRect(yMax);
						updateGraph(yMax, 'red', obsMaxYear);
					}
				});

		svg2.append("text")
			 .attr("pointer-events", "none")
			 .attr("x", 10)
			 .attr("y", 17.5)
			 .text("Rescale without")
				 .style("font-size", "12px")
				 .style("fill", "black");

		svg2.append("text")
			 .attr("pointer-events", "none")
			 .attr("x", 10)
			 .attr("y", 32.5)
			 .text("Las Vegas Shooting")
				 .style("font-size", "12px")
				 .style("fill", "black");

			console.log(yMax);

			var createGraph = function() {
				d3.csv("../assets/us_harmed_victim_forecast_data.csv", function(data) {
				// format the data
				data.forEach(function(d) {
						d.date = parseTime(d.date);
						d.num_harmed = +d.num_harmed;
						d.trend = +d.trend;
						d.year = +d.year;
						d.non_observation = +d.non_observation;
				});
				// Scale the range of the data
				x.domain(d3.extent(data, function(d) { return d.date; }));
				y.domain([0, d3.max(data, function(d) { return d.num_harmed + 25; })]);
				// Add the circles.
				svg.selectAll("circle")
						.data(data)
						.enter()
						.append("circle")
							.attr("pointer-events", "none")
							.attr("r", 2)
							.attr("cx", function(d) { return x(d.date); })
							.attr("cy", function(d) { return y(d.num_harmed); })
							.style("fill", function(d) {
								if ( d.non_observation==1 )
								{ return 'transparent' }
								else
								{ return 'white' }
							})
							.style("stroke", function(d) {
								if ( d.non_observation==1 )
								{ return 'transparent' }
								else
								{ return 'black' }
							});
				// define the line
				var valueLine = d3.line()
						.x(function(d) { return x(d.date); })
						.y(function(d) { return y(d.trend); });
				// Add the valueline path.
				svg.append("path")
						.data([data])
						.attr("pointer-events", "none")
						.attr("class", "line")
						.attr("d", valueLine)
						.style("stroke", "red")
						.style("stroke-width", 3);
				// Add the X Axis
			  svg.append("g")
						.attr("class", "x axis")
			      .attr("transform", "translate(0," + height + ")")
						.style("font-size", "12px")
			      .call(d3.axisBottom(x));
			  // Add the Y Axis
			  svg.append("g")
						.attr("class", "y axis")
						.style("font-size", "12px")
			      .call(d3.axisLeft(y));

				});
		};

			var updateGraph = function(maximumY, trendColor, hoverYear) {
				d3.csv("../assets/us_harmed_victim_forecast_data.csv", function(data) {
				// format the data
				data.forEach(function(d) {
						d.date = parseTime(d.date);
						d.num_harmed = +d.num_harmed;
						d.trend = +d.trend;
						d.year = +d.year;
						d.non_observation = +d.non_observation;
				});
				// Scale the range of the data
				x.domain(d3.extent(data, function(d) { return d.date; }));
				y.domain([0, maximumY + 25]);
				// y.domain([0, maximumY + 25]);
				// Add the circles.
				svg.selectAll("circle")
						.data(data)
						.attr("pointer-events", "none")
						.attr("r", 2)
						.attr("cx", function(d) { return x(d.date); })
						.attr("cy", function(d) { return y(d.num_harmed); })
						.style("fill", function(d) {
							if ( d.non_observation==1 || d.year > hoverYear )
							{ return 'transparent' }
							else
							{ return 'white' }
						})
						.style("stroke", function(d) {
							if ( d.non_observation==1 || d.year > hoverYear )
							{ return 'transparent' }
							else
							{ return 'black' }
						});
				// define the line
				var valueLine = d3.line()
						.x(function(d) { return x(d.date); })
						.y(function(d) { return y(d.trend); });
				// Add the valueline path.
				svg.select("path")
						.data([data])
						.attr("pointer-events", "none")
						.attr("class", "line")
						.attr("d", valueLine)
						.style("stroke", trendColor)
						.style("stroke-width", 3);

				});
		};

			var createRect = function(maximumY) {
				d3.csv("../assets/us_harmed_victim_forecast_data.csv", function(data) {
				// format the data
				data.forEach(function(d) {
						d.date = parseTime(d.date);
						d.num_harmed = +d.num_harmed;
				});
				// Scale the range of the data
				x.domain(d3.extent(data, function(d) { return d.date; }));
				// y.domain([0, d3.max(data, function(d) { return d.num_harmed + 25; })]);
				y.domain([0, maximumY + 25]);

				var yearMouseover = function(d) {
					d3.select(this)
						.style("stroke", "black")
						.style("stroke-width", 3)
						.style("cursor", "pointer");
					if (allYears[Number(d)] < obsMaxYear)
					{ updateGraph(yMax, 'grey', allYears[Number(d)]); }
					else
					{ updateGraph(yMax, 'red', obsMaxYear); };
				};

				var marginMouseover = function(d) {
					updateGraph(yMax, 'red', obsMaxYear);
				};
				// add the year rect boundaries
				var yearRect = svg.selectAll()
						.data(nydKeys, function(d) { return d; })
						.enter();
				// add the margin rect boundaries
				var marginRect = svg.selectAll()
						.data(marginRectDicKeys, function(d) { return d; })
						.enter();

				yearRect.append("rect")
							.attr("x", function(d) { return x(allDates[nydDic[d]]); })
							.attr("y", function(d) { return 0 })
							.attr("rx", 4)
							.attr("ry", 4)
							.attr("width", function(d) { return (width/numRows)*obsPerYearDic[allYears[Number(d)]] } )
							.attr("height", height )
							.style("fill", "transparent")
							.style("stroke", "transparent")
							// .style("stroke-width", 3)
							.on("mouseover", yearMouseover)
							.on("mouseleave", mouseLeave);

				marginRect.append("rect")
						.attr("x", function(d) { return marginRectDic[d]["x"]; })
						.attr("y", function(d) { return marginRectDic[d]["y"]; })
						.attr("rx", 4)
						.attr("ry", 4)
						.attr("width", function(d) { return marginRectDic[d]["width"]; })
						.attr("height", function(d) { return marginRectDic[d]["height"]; })
						.style("fill", 'transparent')
						.style("stroke", "transparent")
						// .style("stroke", "black")
						.style("stroke-width", 3)
						.on("mouseover", marginMouseover);

				});
			};

			createGraph();
			createRect(yMax);

		});

		</script>
	</body>
</html>
