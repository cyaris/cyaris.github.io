<!-- <!DOCTYPE html> -->
<html>
	<head>
		<style type='text/css'>

			@media (max-width:990px){
	      #check_mark_filters {
						display: none;
	      }
				#graph_hover_status {
						display: none;
	      }
				#graph {
						display: none;
	      }
				#metrics_and_sliders {
						display: none;
	      }
				#gva_data_credit {
						display: none;
	      }
		  }

		  @media (min-width:990px){
				#hidden_project_explained {
					display: none;
		    }
		  }

			.path {
			  fill: none;
			  stroke-width: 3.5px;
			}

			div.tooltip {
			  padding: 10px;
				font-size: 12px;
				border-width: 1px;
			}

		</style>
	</head>
	<body>
		<div id='hidden_project_explained' align='left' style='margin-bottom:150px;'>
			<p>While I'm flattered you came to check out my project, it has several interactive features that work best on desktop. So, grab a computer and come back soon!</p>
		</div>
		<div style='margin-top:-115px; margin-bottom:40px;'>
			<div id='check_mark_filters' align='right'></div>
			<div class='no_selection no_events' id='graph_hover_status' align='center' style='margin-bottom:5px;'></div>
			<!-- Create a div where the graph will take place -->
			<div id='graph' align='center'></div>
			<div id='metrics_and_sliders' align='center'></div>
			<div id='gva_data_credit' align='left'>
				<p>All data compiled by <a href='https://gunviolencearchive.org' target='_blank'>Gun Violence Archive (GVA)</a>, a not for profit corporation formed in 2013 to provide online public access to accurate information about gun-related violence in the United States.</p>
			</div>
		</div>
		<script type='text/javascript' src='{{site.url}}/assets/js/sma/index.js'></script>
		<script type='text/javascript'>

			// set the dimensions and margins of the graph
			margin = {top: 20, right: 20, bottom: 65, left: 65},
	    width = 750 - margin.left - margin.right,
	    height = 450 - margin.top - margin.bottom,
			topBody = height + margin.top,
			leftBody = margin.left + width,
			fullWidth = leftBody + margin.right,
			leftBodyFifth = (margin.left+width)/5,
			leftMarginAdj = (margin.left/2)-5.5,
			// and for the filter checkboxes
			checkFilterWidth = 200/7.75,
			checkFilterHeight = 40/1.65,
			// set the dimensions of the margin rects
			marginRectDic = {
				0: {'x': -(margin.left), 'y': -7.5,
				'width': margin.left, 'height': height + 7.5},
				1: {'x': width, 'y': -7.5,
				'width': margin.right, 'height': height + 7.5},
				2: {'x': -(margin.left), 'y': -(margin.top),
				'width': fullWidth, 'height': margin.top - 7.5},
				3: {'x': -(margin.left), 'y': height,
				'width': fullWidth, 'height': margin.bottom},
			},
			marginRectDicKeys = Object.keys(marginRectDic);
			// parse the date / time and set the ranges
			parseTime = d3.timeParse('%Y-%m-%d'),
			x = d3.scaleTime().range([0, width]),
			y = d3.scaleLinear().range([height, 0]);
			// append the svg object to the body of the page
			addStdGroupSVG('svg1', 'graph', fullWidth, topBody + margin.bottom, margin.left, margin.top, 'auto');
			// adding svg2 here so it becomes a global variable that can be accessed by svg1
			addStdSVG('svg2', 'graph_hover_status', fullWidth - leftMarginAdj, 25, 12.5, 2.5, 'auto');
			// append the svg objects to the body of the page
			addStdSVG('svg3', 'check_mark_filters', 175, 102.5, 210, 142, 'auto');
			addStdSVG('svg4', 'metrics_and_sliders', fullWidth, 125, 0, 0, 'auto');

			d3.csv('{{site.url}}/assets/csv/us_gun_violence_forecasting/us_harmed_victim_forecast_data.csv', function(data) {

				var tooltipMO = function(d) {
							d3.select(this).style('cursor', 'help');
							rectID = d3.select(this)['_groups'][0][0]['id'];
							toolTip = rectID.substring(0, rectID.length - 5);
							d3.select('#' + toolTip).style('opacity', 1);
							d3.select('#' + toolTip + '_circle').style('fill', 'white').style('stroke', tooltipSymbolColor).attr('r', 9);
							yTextLoc = Number(d3.select('#' + toolTip + '_i').attr('y')) + 0.5;
							d3.select('#' + toolTip + '_i').attr('y', yTextLoc).style('fill', tooltipSymbolColor).style('stroke', tooltipSymbolColor).style('font-size', '13px');
							if ( toolTip=='lv_tooltip' ) {

								svg1.selectAll('#circle_obs')
									.filter(function(d) { return d.num_harmed==maxOb; })
									.style('stroke-width', 7.5)
									.style('opacity', 1);

								addStdRect(svg3, null, 'tooltip_region_hide_rect', 0, 35, 100, 25, 'transparent', 0, 1, 'white', 1, null, null, null);
							}
							else if ( toolTip =='metrics_tooltip' )
							{ addStdRect(svg4, null, 'tooltip_region_hide_rect', 200, 0, 215, 130, 'transparent', 0, 1, 'white', 1, null, null, null); }
				},
						tooltipML = function(d) {
							rectID = d3.select(this)['_groups'][0][0]['id'];
							toolTip = rectID.substring(0, rectID.length - 5);
							d3.select('#' + toolTip).style('opacity', 0);
							d3.select('#' + toolTip + '_circle').style('fill', tooltipSymbolColor).style('stroke', 'transparent').attr('r', 7.5);
							yTextLoc = Number(d3.select('#' + toolTip + '_i').attr('y')) - 0.5;
							d3.select('#' + toolTip + '_i').attr('y', yTextLoc).style('fill', 'white').style('stroke', 'white').style('font-size', '11.5px');
							d3.select('#tooltip_region_hide_rect').remove();
							if ( toolTip=='lv_tooltip' ) {

								svg1.selectAll('#circle_obs')
									.filter(function(d) { return d.num_harmed==maxOb; })
										.style('opacity', function() {
											if ( svg3.select('#obs_filter_check_mark').style('opacity')==1 && obsSlider.value()==0 )
											{ return 1; }
											else
											{ return 0; }
										})
										.style('stroke-width', 0.5);
							}
				};

				maxYearObserved = [],
				allDates = [],
				allObs = [],
				allYears = [],
				newYearsDayDic = {},
				obsPerYearDic = {},
				obsMADic = {},
				tsPredDic = {},
				tsMADic = {},
				obsCumDic = {};

				numObsCumCount = 0,
				numVictimsCumCount = 0;

				obsColor = 'rgb(112,128,144)',
				overallModelColor = 'rgb(250,98,95)',
				hoverModelColor = 'rgb(0,192,127)',
				tooltipSymbolColor = 'rgb(0,122,255)';

				numRows = data.length,
				minYear = d3.min(data, function(d) { return d.year }),
				maxYear = d3.max(data, function(d) { return d.year });
				// format the data
				data.forEach(function(d) {
					d.date = parseTime(d.date),
					allDates.push(d.date),
					d.num_harmed = +d.num_harmed;
					if ( d.non_observation!=1 )
					{ allObs.push(d.num_harmed); };
					if ( d.nyd!=null && d.nyd!='' )
					{ newYearsDayDic[d.nyd] = d.index; };
				});

				for ( var i = minYear; i <= maxYear; i++ ) {
					allYears.push(i),
					daysPerYearCount = 0,
					pred_year_array = [];
					data.forEach(function(d) {
						if ( d.year==i )
						{ daysPerYearCount+=1; }
						if ( d.year==i && d.non_observation!=1 ) {
							maxYearObserved.push(i),
							numObsCumCount+=1,
							numVictimsCumCount+=d.num_harmed; }
						pred_year_array.push(+d['pred_' + String(i)]);
					});
					obsPerYearDic[i] = daysPerYearCount,
					obsCumDic[i] = numObsCumCount,
					tsPredDic[i] = pred_year_array;
				};

				overallTimeFrame = String(allYears[0]) + 'â€“Present',
				maxOb = d3.max(allObs),
				// set initial yMax which will be changed as scale is adjusted
				yMax = maxOb,
				allObsSrtd = allObs.slice(0).sort(function(a,b){return b-a}),
				nydKeys = Object.keys(newYearsDayDic),
				maxYearObserved = d3.max(maxYearObserved),
				numFuturePredDays = numRows - allObs.length;

				// today = new Date(),
				// mostRecObsDate = allDates[allObs.length].toLocaleDateString('en-US');
				// daysSinceMostRecObs = parseInt(Math.round((Math.abs(today - allDates[allObs.length])/1000)/86400)).toLocaleString();
				// console.log('Today\'s date is ' + today.toLocaleDateString('en-US') + '.');
				// console.log('The most recent date recorded is ' + mostRecObsDate + ', ' + daysSinceMostRecObs + ' days ago.');

				sliderData = {
					'obs': {
						'ticks': [0, 5, 10, 15, 20, 25, 30],
						'step': 5,
						'default': 0,
						'width': 120
					},
					'ts': {
						'ticks': [5, 10, 15, 20, 25, 30],
						'step': 5,
						'default': 10,
						'width': 112.5
					}
				};

				obsSlider = d3.sliderBottom()
							.min(d3.min(sliderData['obs']['ticks']))
	  					.max(d3.max(sliderData['obs']['ticks']))
	  					.width(sliderData['obs']['width'])
							.step(sliderData['obs']['step'])
							.tickValues(sliderData['obs']['ticks'])
							.default(sliderData['obs']['default'])
							.on('onchange', function(d) {
								updateGraph(maxYearObserved, 'obs_slider');
							}),
				tsSlider = d3.sliderBottom()
							.min(d3.min(sliderData['ts']['ticks']))
							.max(d3.max(sliderData['ts']['ticks']))
							.width(sliderData['ts']['width'])
							.step(sliderData['ts']['step'])
							.tickValues(sliderData['ts']['ticks'])
							.default(sliderData['ts']['default'])
							.on('onchange', function(d) {
								updateGraph(maxYearObserved, 'ts_slider');
							});

				for ( var i = 1; i <= sliderData['obs']['ticks'].length-1; i++ ) {
					obsMADic[sliderData['obs']['ticks'][i]] = sma(allObs, sliderData['obs']['ticks'][i]).map(Number);
					for ( var z = minYear; z <= maxYear; z++ ) {
						// using 'obs' instead of 'ts' here so an error isn't thrown.
						tsMADic[String(z) + '_' + String(sliderData['obs']['ticks'][i])] = sma(tsPredDic[z], sliderData['obs']['ticks'][i]).map(Number);
					};
				};

				overallCol = 'pred_' + String(maxYearObserved),
				overallYearlyTrendCol = 'yearly_trend_calc_' + String(maxYearObserved),
				overallPredPast = 0,
				overallPredFuture = 0,
				overallYearlyTrendPast = 0,
				overallYearlyTrendFuture = 0,
				overallRMSE = 0;

		    // format the data
		    data.forEach(function(d) {
	        d[overallCol] = +d[overallCol];
					d[overallYearlyTrendCol] = +d[overallYearlyTrendCol];
					if ( d.non_observation!=1 ) {
						overallPredPast+=d[overallCol]
						difference = d[overallCol] - d.num_harmed;
						overallRMSE+=Math.pow(difference, 2)/obsCumDic[maxYearObserved];
						overallYearlyTrendPast+=d[overallYearlyTrendCol];
					}
					else {
						overallPredFuture+=d[overallCol];
						overallYearlyTrendFuture+=d[overallYearlyTrendCol];
					};
		    });

				overallTotalVictims = parseInt(Math.round(overallPredPast/obsCumDic[maxYearObserved])).toLocaleString(),
				overallPredFuturePerDay = parseInt(Math.round(overallPredFuture/numFuturePredDays)).toLocaleString(),
				overallPredPast = parseInt(Math.round(overallPredPast)).toLocaleString(),
				overallPredFuture = parseInt(Math.round(overallPredFuture)).toLocaleString(),
				overallYearlyTrendPast = parseInt(Math.round(overallYearlyTrendPast/(obsCumDic[maxYearObserved]-numFuturePredDays))).toLocaleString(),
				overallYearlyTrendFuture = parseInt(Math.round(overallYearlyTrendFuture/numFuturePredDays)).toLocaleString(),
				overallRMSE = parseInt(Math.round(Math.sqrt(overallRMSE))).toLocaleString();

		    // Scale the range of the data
		    x.domain(d3.extent(data, function(d) { return d.date; }));
		    y.domain([0, d3.max(data, function(d) { return d.num_harmed + 15; })]);

				// Add the X Axis
				svg1.append('g')
						.attr('pointer-events', 'none')
						.attr('transform', 'translate(0,' + height + ')')
						.style('font-size', '12px')
					.call(d3.axisBottom(x));
				// Add the Y Axis
				svg1.append('g')
						.attr('pointer-events', 'none')
						.attr('class', 'y_axis')
						.style('font-size', '12px')
					.call(d3.axisLeft(y));
				/////////////////////////////////////////////
				/////////////////////////////////////////////

				addStdLine(svg1, 'obs_legend_line', (margin.right/2), (margin.right/2) + 12.5, 6, 6, obsColor, 3.5, null, 0);
				addStdLine(svg1, 'overall_legend_line', (margin.right/2), (margin.right/2) + 12.5, 21, 21, overallModelColor, 3.5, null, 1);
				addStdLine(svg1, 'hover_legend_line', (margin.right/2), (margin.right/2) + 12.5, 36, 36, hoverModelColor, 3.5, null, 0);

				addStdCircle(svg1, 'obs_legend_circle', (margin.right/2) + 6, 6, obsColor);

				addStdText(svg1, null, 'obs_legend_null', (margin.right/2) + 0.75, 10.5, '15px', 'normal', 0, 0.5, 'âˆ…');
				addStdText(svg1, null, 'overall_legend_null', (margin.right/2) + 0.75, 25.5, '15px', 'normal', 0, 0.5, 'âˆ…');
				addStdText(svg1, null, 'hover_legend_null', (margin.right/2) + 0.75, 40.5, '15px', 'normal', 1, 0.5, 'âˆ…');

				addStdText(svg1, null, null, (margin.right/2) + 17.5, 10, '12px', 'normal', 1, 0, 'Daily Observations');
				addStdText(svg1, null, null, (margin.right/2) + 17.5, 25, '12px', 'normal', 1, 0, 'Overall Model');
				addStdText(svg1, null, null, (margin.right/2) + 17.5, 40, '12px', 'normal', 1, 0, 'Comparative Model');

				futureTimeFrameXLoc = (width/numRows)*obsCumDic[allYears[allYears.length-1]];
				addStdRect(svg1, null, 'future_pred_days_rect', futureTimeFrameXLoc + 0.7, -7.5, width - futureTimeFrameXLoc, height + 7.5, 'transparent', 0, 1, 'black', 0.075, null, null, null);
				textInput = 'Next ' + String(numFuturePredDays) + ' days...',
				textWidth = getTextWidth(svg1, textInput, 12);
				addStdText(svg1, null, null, futureTimeFrameXLoc + 0.7 + ((width - futureTimeFrameXLoc - textWidth)/2), 10, '12px', 'italic', 1, 0, textInput);

				function addGunViolenceObservations(svgInput, dataInput, idInput, trueObservation, yVariable, fillColor, strokeColor) {

					svgInput.selectAll('#' + idInput)
							.data(dataInput)
							.enter()
							.append('circle')
								.filter(function(d) { return d.non_observation!=1; })
								.attr('pointer-events', 'none')
								.attr('id', idInput)
								.attr('r', 2)
								.attr('cx', function(d) { return x(d.date); })
								.attr('cy', function(d) { return y(d[yVariable]); })
								.style('fill', fillColor)
								.style('stroke', strokeColor)
								.style('stroke-width', 0.5);
				};

		    // add the raw observations as circles.
				addGunViolenceObservations(svg1, data, 'circle_obs', true, 'num_harmed', obsColor, 'black');

				// defining all three lines (not including legend lines).
				// all three are affected by moving averages.
				obsMALine = d3.line().x(null).y(null);
				addStdPath(svg1, [data], 'obs_ma_line', obsMALine, obsColor, 0);

				overallMALine = d3.line()
						.defined(function(d) { return d.index>tsSlider.value()-1; })
						.x(function(d) { return x(d.date); })
						.y(function(d) { return y(tsMADic[String(maxYearObserved) + '_' + String(sliderData['ts']['default'])][d.index-tsSlider.value()]); });
				addStdPath(svg1, [data], 'overall_ma_line', overallMALine, overallModelColor, 1);

				hoverMALine = d3.line().x(null).y(null);
				addStdPath(svg1, [data], 'hover_ma_line', hoverMALine, hoverModelColor, 0);

				addStdRect(svg1, null, 'graph_rect_outline', -(margin.left/2)-5.5, -(margin.top)+.5, width+(margin.left/2)+margin.right+5, height+margin.top+(margin.bottom/2), 'black', 1, 1, 'transparent', 1, null, null, null);
				addStdLine(svg1, null, futureTimeFrameXLoc + 0.7, futureTimeFrameXLoc + 0.7, function(d) { return y(y.domain()[0]) + 5}, -5.5, 'black', 2, ('4, 4'), 1);
				addStdLine(svg1, null, futureTimeFrameXLoc + 0.7, width, -7.5, -7.5, 'black', 2, ('4, 4'), 1);

				// Add header text for svg2
				addStdText(svg2, null, 'hover_graph_header', ((fullWidth - leftMarginAdj)/2)-120, 17.5, '13.5px', 'normal', 1, 0.25, 'Hover to Compare Historical Forecasts');
				addStdText(svg2, null, 'comparing_graph_header', ((fullWidth - leftMarginAdj)/2)-95, 17.5, '13.5px', 'italic', 0, 0.25, 'Comparing Historical Forecasts...');


				/////////////////////////////////////////////
				/////////////////////////////////////////////

				updateGraphMO = function(d) {
					svg4.selectAll('#dropdown_option').remove();
					// updating graph here in case of failure with marginmouseover/marginmouseleave in svg1
					updateGraph(maxYearObserved, null);
				};

				addStdRect(svg4, null, null, 0, 0, fullWidth, 125, 'transparent', 0, 1, 'transparent', 1, updateGraphMO, null, null);
				/////////////////////////////////////////////
				/////////////////////////////////////////////


				// rect needed between rects to run cursorPointer function.
				addStdRect(svg3, null, null, 1, 0, checkFilterWidth, 108.5 + checkFilterHeight + 1, 'transparent', 0, 1, 'transparent', 1, updateGraphMO, null, null);

				addStdRect(svg3, null, 'lv_filter', 1, 3.5, checkFilterWidth, checkFilterHeight, 'black', 1, 1, 'transparent', 1, generalRectMO, generalRectML, filterClick);
				addStdText(svg3, null, 'lv_filter_check_mark', 6, 22.5, '20px', 'normal', 1, 0, 'âœ“');
				addStdText(svg3, null, null, 34, 12, '12px', 'normal', 1, 0, 'Scaling includes the');
				addStdText(svg3, null, null, 34, 26.5, '12px', 'normal', 1, 0, 'Las Vegas Shooting');

				textInput = 'The Las Vegas shooting is the deadliest mass shooting in US history. With 548 total victims killed/injured, it is a major outlier in this dataset. Filter to see how this observation affects the scaling of the entire graph.';
				defineTooltip('check_mark_filters', 'lv_tooltip', '780px', '67.5px', '210px', '145px', 0, textInput);
				addStdRect(svg3, null, 'lv_tooltip_rect', 148.5, 11.5, 20, 20, 'transparent', 0, 1, 'transparent', 1, tooltipMO, tooltipML, null);
				// more specific ids will be added in the function itself.
				addTooltipSymbol(svg3, 'lv_tooltip', 158.5, 21.5, 157, 25.5, null);

				addStdRect(svg3, null, 'obs_filter', 1, 38.5, checkFilterWidth, checkFilterHeight, 'black', 1, 1, 'transparent', 1, generalRectMO, generalRectML, filterClick);
				addStdText(svg3, null, 'obs_filter_check_mark', 6, 57.5, '20px', 'normal', 1, 0, 'âœ“');
				addStdText(svg3, null, null, 34, 47.5, '12px', 'normal', 1, 0, 'Displaying');
				addStdText(svg3, null, null, 34, 62, '12px', 'normal', 1, 0, 'Daily Observations');

				addStdRect(svg3, null, 'ts_filter', 1, 73.5, checkFilterWidth, checkFilterHeight, 'black', 1, 1, 'transparent', 1, generalRectMO, generalRectML, filterClick);
				addStdText(svg3, null, 'ts_filter_check_mark', 6, 92.5, '20px', 'normal', 1, 0, 'âœ“');
				addStdText(svg3, null, null, 34, 82.5, '12px', 'normal', 1, 0, 'Displaying');
				addStdText(svg3, null, null, 34, 97, '12px', 'normal', 1, 0, 'Time Series Models');

				function filterClick() {

					rectID = d3.select(this)['_groups'][0][0]['id'];
					checkMarkID = '#' + String(rectID) + '_check_mark';

					if ( rectID=='lv_filter' ) {
						if ( svg3.select(checkMarkID).style('opacity')==1 )
						{ yMax = allObsSrtd[1]; }
						else
						{ yMax = maxOb; }
						// Rescale the range of the data vertically
						y.domain([0, yMax + 15]);
						// Update the Y Axis
						svg1.select('.y_axis').call(d3.axisLeft(y));
						// Update the circles.
						svg1.selectAll('#circle_obs').attr('cy', function(d) { return y(d.num_harmed); });
						// Redefine the overall Pred line path.
						overallMALine = d3.line()
						// CHECK OUT: No idea why this is needed.
								.defined(function(d) { return d.index>tsSlider.value()-1; })
								.x(function(d) { return x(d.date); })
								.y(function(d) { return y(tsMADic[String(maxYearObserved) + '_' + String(tsSlider.value())][d.index-tsSlider.value()]); });
						svg1.select('#overall_ma_line').attr('d', overallMALine);
					}
					if ( svg3.select(checkMarkID).style('opacity')==1 )
					{ svg3.select(checkMarkID).style('opacity', 0); }
					else
					{ svg3.select(checkMarkID).style('opacity', 1); }
					updateGraph(maxYearObserved, rectID);
				};

				dropDownSelected = overallTimeFrame,
				dropDownOption = 'Next ' + String(numFuturePredDays) + ' Days';

				var dropDownSelectedMO = function(d) {
						generalRectMO;
						d3.select(this)
							.style('stroke', 'black');
						addStdRect(svg4, null, 'dropdown_option', leftMarginAdj + 1, 32.5, 91, 17.5, 'black', 1, 1, 'white', 1, generalRectMO, generalRectML, dropDownOptionClick);
						addStdText(svg4, null, 'dropdown_option', leftMarginAdj + 6, 45, '12px', 'normal', 1, 0, dropDownOption);
				},

						dropDownSelectedClick = function(d) {
						svg4.selectAll('#dropdown_option').remove();
						dropDownSelectedMO();
				},
						dropDownOptionClick = function(d) {
						svg4.selectAll('#dropdown_option').remove();
						svg4.select('#dropdown_selected_text').remove();

						if ( dropDownSelected==overallTimeFrame ) {
							svg4.selectAll('#past_prediction_specific').remove();
							futurePredictionSpecific();
							dropDownSelected = 'Next ' + String(numFuturePredDays) + ' Days';
							dropDownOption = overallTimeFrame;
							d3.select('#metrics_methodology_tooltip').style('height', '92.5px').html(futurePredText);
						}
						else {
							svg4.selectAll('#future_prediction_specific').remove();
							pastPredictionSpecific();
							dropDownSelected = overallTimeFrame;
							dropDownOption = 'Next ' + String(numFuturePredDays) + ' Days';
							d3.select('#metrics_methodology_tooltip').style('height', '100px').html(pastPredText);
						}
						addStdText(svg4, null, 'dropdown_selected_text', leftMarginAdj + 6, 27.5, '12px', 'normal', 1, 0, dropDownSelected);
				};

				addStdText(svg4, null, null, leftMarginAdj, 9.25, '12px', 'normal', 1, 0, 'Prediction Timeframe');
				addStdRect(svg4, null, null, leftMarginAdj + 1, 15, 91, 17.5, 'black', 1, 1, 'transparent', 1, dropDownSelectedMO, generalRectML, dropDownSelectedClick);
				addStdText(svg4, null, 'dropdown_selected_text', leftMarginAdj + 6, 27.5, '12px', 'normal', 1, 0, dropDownSelected);

				textInput = 'Use dropdown to compare time series model predictions for dates that took place in the past, or, take place in the next year (' + String(numFuturePredDays) + ' days).';
				defineTooltip('metrics_and_sliders', 'metrics_tooltip', '210px', '480px', '220px', '95px', 0, textInput);
				addStdRect(svg4, null, 'metrics_tooltip_rect', 123.5, 13.5, 20, 20, 'transparent', 0, 1, 'transparent', 1, tooltipMO, tooltipML, null);
				// more specific ids will be added in the function itself.
				addTooltipSymbol(svg4, 'metrics_tooltip', 133.5, 23.5, 132, 27.5, null);

				pastPredText = 'Model Input: What years of data were used to generate these predictions?<br>Total Victims: How many total victims does the model think there been since 1/1/14?<br>Avg Victims per Day: How many victims does the model think there have been daily since 1/1/14?<br>Avg Yearly Trend: What is the average change between these predictions annually?<br>RMSE: How do these predictions compare to the actual number of victims recorded daily since 1/1/14?',
				futurePredText = 'Model Input: What years of data were used to generate these predictions?<br>Total Victims: How many total victims does the model think there will be in the next 365 days?<br>Avg Victims per Day: How many victims does the model think there will be daily for the next 365 days?<br>Avg Yearly Trend: What is the average change between these predictions annually?';
				defineTooltip('metrics_and_sliders', 'metrics_methodology_tooltip', '40.5px', '513.5px', '600px', '112.5px', 0, pastPredText);
				addStdRect(svg4, null, 'metrics_methodology_tooltip_rect', leftMarginAdj-27.5, (height/2)-139, 20, 20, 'transparent', 0, 1, 'transparent', 1, tooltipMO, tooltipML, null);
				// more specific ids will be added in the function itself.
				addTooltipSymbol(svg4, 'metrics_methodology_tooltip', leftMarginAdj-17.5, (height/2)-129, -55, 13.5, 'rotate(-90)');
				addStdText(svg4, null, 'metrics_methodology_tooltip_label', -95, leftMarginAdj-12.5, '15px', 'normal', 1, 0.25, 'Metrics');
				svg4.select('#metrics_methodology_tooltip_label').attr('transform', 'rotate(-90)').style('text-anchor', 'middle');

				addStdLine(svg4, null, leftMarginAdj, 197.75, 40, 40, 'black', 3.5, null, 1);
				addStdLine(svg4, null, 197.75, 296.875, 40, 40, overallModelColor, 3.5, null, 1);
				addStdLine(svg4, null, 296.875, 396, 40, 40, hoverModelColor, 3.5, null, 1);
				textWidth = getTextWidth(svg1, 'Overall', 12);
				addStdText(svg4, null, null, 296.875 - textWidth, 15, '12px', 'normal', 1, 0, 'Overall');
				textWidth = getTextWidth(svg1, 'Model', 12);
				addStdText(svg4, null, null, 296.875 - textWidth, 30, '12px', 'normal', 1, 0, 'Model');
				textWidth = getTextWidth(svg1, 'Comparative', 12);
				addStdText(svg4, null, null, 396 - textWidth, 15, '12px', 'normal', 1, 0, 'Comparative');
				textWidth = getTextWidth(svg1, 'Model', 12);
				addStdText(svg4, null, null, 396 - textWidth, 30, '12px', 'normal', 1, 0, 'Model');

				addStdText(svg4, null, null, leftMarginAdj, 55, '12px', 'normal', 1, 0, 'Model Input:');
				addStdText(svg4, null, null, leftMarginAdj, 70, '12px', 'normal', 1, 0, 'Total Victims:');
				addStdText(svg4, null, null, leftMarginAdj, 85, '12px', 'normal', 1, 0, 'Avg Victims per Day:');
				addStdText(svg4, null, null, leftMarginAdj, 100, '12px', 'normal', 1, 0, 'Avg Yearly Trend');
				textInput = 'Avg Yearly Trend',
				textWidth = getTextWidth(svg1, textInput, 12);
				addStdText(svg4, null, null, leftMarginAdj + textWidth + 4, 100, '12px', 'italic', 1, 0, '(Rounded)');
				textInput = 'Avg Yearly Trend (Rounded)',
				textWidth = getTextWidth(svg1, textInput, 12);
				addStdText(svg4, null, null, leftMarginAdj + textWidth - 2, 100, '12px', 'normal', 1, 0, ':');

				textInput = overallTimeFrame,
				textWidth = getTextWidth(svg1, textInput, 12);
				addStdText(svg4, null, null, 296.875 - textWidth, 55, '12px', 'normal', 1, 0, textInput);

				function pastPredictionSpecific() {

					addStdText(svg4, null, 'past_prediction_specific', leftMarginAdj, 115, '12px', 'normal', 1, 0, 'RMSE');
					textInput = 'RMSE',
					textWidth = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, null, 'past_prediction_specific', leftMarginAdj + textWidth + 4, 115, '12px', 'italic', 1, 0, '(Rounded)');
					textInput = 'RMSE (Rounded)',
					textWidth = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, null, 'past_prediction_specific', leftMarginAdj + textWidth - 2, 115, '12px', 'normal', 1, 0, ':');

					textInput = overallPredPast,
					textWidth = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, null, 'past_prediction_specific', 296.875 - textWidth, 70, '12px', 'normal', 1, 0, textInput);
					textInput = overallTotalVictims,
					textWidth = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, null, 'past_prediction_specific', 296.875 - textWidth, 85, '12px', 'normal', 1, 0, textInput);
					textInput = overallYearlyTrendPast,
					textWidth = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, null, 'past_prediction_specific', 296.875 - textWidth, 100, '12px', 'normal', 1, 0, textInput);
					textInput = String(overallRMSE),
					textWidth = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, null, 'past_prediction_specific', 296.875 - textWidth, 115, '12px', 'normal', 1, 0, textInput);
				};

				pastPredictionSpecific();

				function futurePredictionSpecific() {

					textInput = overallPredFuture,
					textWidth = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, null, 'future_prediction_specific', 296.875 - textWidth, 70, '12px', 'normal', 1, 0, textInput);
					textInput = overallPredFuturePerDay,
					textWidth = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, null, 'future_prediction_specific', 296.875 - textWidth, 85, '12px', 'normal', 1, 0, textInput);
					textInput = overallYearlyTrendFuture,
					textWidth = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, null, 'future_prediction_specific', 296.875 - textWidth, 100, '12px', 'normal', 1, 0, textInput);
				};

				textInput = 'Hover to',
				textWidth = getTextWidth(svg1, textInput, 12);
				addStdText(svg4, 'hover_metrics', 'hover_metrics_instruction', 396 - textWidth, 55, '12px', 'normal', 1, 0, textInput);
				textInput = 'Compare',
				textWidth = getTextWidth(svg1, textInput, 12);
				addStdText(svg4, 'hover_metrics', 'hover_metrics_instruction', 396 - textWidth, 70, '12px', 'normal', 1, 0, textInput);

				svg4.append('g')
						.attr('transform', 'translate(436,45)')
						.call(obsSlider);

				svg4.append('g')
						.attr('transform', 'translate(616,45)')
						.call(tsSlider);

				addStdText(svg4, null, null, 425, 15, '12px', 'normal', 1, 0, 'Moving Average for');
				addStdText(svg4, null, null, 425, 30, '12px', 'normal', 1, 0, 'Daily Observations');
				addStdText(svg4, null, null, 605, 15, '12px', 'normal', 1, 0, 'Moving Average for');
				addStdText(svg4, null, null, 605, 30, '12px', 'normal', 1, 0, 'Time Series Models');

				textInput = 'Adjust the slider to specify a moving average for displaying daily observations. Units are in days, with 0 days displaying the actual/recorded observation.'
				defineTooltip('metrics_and_sliders', 'obs_ma_tooltip', '605px', '472.5px', '205px', '110px', 0, textInput);
				addStdRect(svg4, null, 'obs_ma_tooltip_rect', 539.5, 14.5, 20, 20, 'transparent', 0, 1, 'transparent', 1, tooltipMO, tooltipML, null);
				// more specific ids will be added in the function itself.
				addTooltipSymbol(svg4, 'obs_ma_tooltip', 549.5, 23.5, 548, 27.5, null);

				textInput = 'Adjust the slider to specify a moving average for displaying time series models. Units are in days, with 0 days displaying the exact prediction on a given day.'
				defineTooltip('metrics_and_sliders', 'ts_ma_tooltip', '420px', '472.5px', '192.5px', '130px', 0, textInput);
				addStdRect(svg4, null, 'ts_ma_tooltip_rect', 722, 14.5, 20, 20, 'transparent', 0, 1, 'transparent', 1, tooltipMO, tooltipML, null);
				// more specific ids will be added in the function itself.
				addTooltipSymbol(svg4, 'ts_ma_tooltip', 732, 23.5, 730.5, 27.5, null);
				/////////////////////////////////////////////
				/////////////////////////////////////////////

				function updatePastHoverMetrics(hoverYear) {

					hoverYearCol = 'pred_' + String(hoverYear),
					hoverYearlyTrendCol = 'yearly_trend_calc_' + String(hoverYear),
					hoverPredPast = 0,
					hoverYearlyTrendPast = 0,
					hoverRMSE = 0;
					// format the data
					data.forEach(function(d) {
						d[hoverYearCol] = +d[hoverYearCol];
						d[hoverYearlyTrendCol] = +d[hoverYearlyTrendCol];
						if ( d.non_observation!=1 ) {
							hoverPredPast+=d[hoverYearCol];
							difference = d[hoverYearCol] - d.num_harmed;
							hoverRMSE+=Math.pow(difference, 2)/obsCumDic[maxYearObserved];
							hoverYearlyTrendPast+=d[hoverYearlyTrendCol];
						}
					});

					hoverPredPastPerDay = parseInt(Math.round(hoverPredPast/obsCumDic[maxYearObserved])).toLocaleString();
					hoverPredPast = parseInt(Math.round(hoverPredPast)).toLocaleString();
					hoverYearlyTrendPast = parseInt(Math.round(hoverYearlyTrendPast/(obsCumDic[maxYearObserved]-numFuturePredDays))).toLocaleString();
					hoverRMSE = parseInt(Math.round(Math.sqrt(hoverRMSE))).toLocaleString();

					if ( hoverYear==allYears[0] )
					{ textInput = String(allYears[0]); }
					else if ( hoverYear!=allYears[0] )
					{ textInput = String(allYears[0]) + 'â€“' + String(hoverYear); }

					svg4.selectAll('#hover_metrics').remove();

					textWidth = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, null, 'hover_metrics', 396 - textWidth, 55, '12px', 'normal', 1, 0, textInput);
					textInput = hoverPredPast,
					textWidth = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, null, 'hover_metrics', 396 - textWidth, 70, '12px', 'normal', 1, 0, textInput);
					textInput = hoverPredPastPerDay,
					textWidth = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, null, 'hover_metrics', 396 - textWidth, 85, '12px', 'normal', 1, 0, textInput);
					textInput = hoverYearlyTrendPast,
					textWidth = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, null, 'hover_metrics', 396 - textWidth, 100, '12px', 'normal', 1, 0, textInput);
					textInput = hoverRMSE,
					textWidth = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, null, 'hover_metrics', 396 - textWidth, 115, '12px', 'normal', 1, 0, textInput);
				};

				function updateFutureHoverMetrics(hoverYear) {

					hoverYearCol = 'pred_' + String(hoverYear),
					hoverYearlyTrendCol = 'yearly_trend_calc_' + String(hoverYear),
					hoverYearlyTrendFuture = 0,
					hoverPredFuture = 0;
					// format the data
					data.forEach(function(d) {
						d[hoverYearCol] = +d[hoverYearCol];
						d[hoverYearlyTrendCol] = +d[hoverYearlyTrendCol];
						if ( d.non_observation==1 ) {
							hoverPredFuture+=d[hoverYearCol];
							hoverYearlyTrendFuture+=d[hoverYearlyTrendCol];
						};
					});

					hoverPredFuturePerDay = parseInt(Math.round(hoverPredFuture/numFuturePredDays)).toLocaleString();
					hoverPredFuture = parseInt(Math.round(hoverPredFuture)).toLocaleString();
					hoverYearlyTrendFuture = parseInt(Math.round(hoverYearlyTrendFuture/numFuturePredDays)).toLocaleString();

					if ( hoverYear==allYears[0] )
					{ textInput = String(allYears[0]); }
					else if ( hoverYear!=allYears[0] )
					{ textInput = String(allYears[0]) + 'â€“' + String(hoverYear); }

					svg4.selectAll('#hover_metrics').remove();

					textWidth = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, null, 'hover_metrics', 396 - textWidth, 55, '12px', 'normal', 1, 0, textInput);
					textInput = hoverPredFuture,
					textWidth = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, null, 'hover_metrics', 396 - textWidth, 70, '12px', 'normal', 1, 0, textInput);
					textInput = hoverPredFuturePerDay,
					textWidth = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, null, 'hover_metrics', 396 - textWidth, 85, '12px', 'normal', 1, 0, textInput);
					textInput = hoverYearlyTrendFuture,
					textWidth = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, null, 'hover_metrics', 396 - textWidth, 100, '12px', 'normal', 1, 0, textInput);
				};

				function updateGraph(hoverYear, sourceObject) {

					if ( svg3.select('#obs_filter_check_mark').style('opacity')==0 ) {

						svg1.select('#obs_legend_null').style('opacity', 1);
						svg1.select('#obs_legend_line').style('opacity', 0);
						svg1.select('#obs_legend_circle').style('opacity', 0);
						svg1.select('#obs_ma_line').style('opacity', 0);
						svg1.selectAll('#circle_obs').style('opacity', 0);
				 	}
					else if ( obsSlider.value()==0 ) {

						svg1.select('#obs_legend_null').style('opacity', 0);
						svg1.select('#obs_legend_line').style('opacity', 0);
						svg1.select('#obs_legend_circle').style('opacity', 1);
						svg1.select('#obs_ma_line').style('opacity', 0);

						svg1.selectAll('#circle_obs')
								.filter(function(d) { return d.non_observation!=1; })
								.style('fill', obsColor)
								.style('stroke', 'black')
								.style('opacity', function(d) {
									if ( d.year <= hoverYear )
									{ return 1 }
									else
									{ return 0.4 }
								})
								.style('stroke-width', 0.5);
					}
					else {

						svg1.select('#obs_legend_null').style('opacity', 0);
						svg1.select('#obs_legend_line').style('opacity', 1);
			 			svg1.select('#obs_legend_circle').style('opacity', 0);
						svg1.select('#obs_ma_line').style('opacity', 1);
						svg1.selectAll('#circle_obs').style('opacity', 0);

		 			 	// Redefine the overall line path.
						obsMALine = d3.line()
			 					.defined(function(d) { return d.index>obsSlider.value()-1 && d.non_observation!=1; })
			 					.x(function(d) { return x(d.date); })
			 					.y(function(d) { return y(obsMADic[obsSlider.value()][d.index-obsSlider.value()]); });

			 			svg1.select('#obs_ma_line').attr('d', obsMALine);
					};

					if ( sourceObject=='ts_slider' ) {

						svg1.select('#overall_legend_null').style('opacity', 0);
						svg1.select('#overall_legend_line').style('opacity', 1);
						svg1.select('#overall_ma_line').style('opacity', 1);

						// Redefine the overall Pred line path.
						overallMALine = d3.line()
								.defined(function(d) { return d.index>tsSlider.value()-1; })
								.x(function(d) { return x(d.date); })
								.y(function(d) { return y(tsMADic[String(maxYearObserved) + '_' + String(tsSlider.value())][d.index-tsSlider.value()]); });

						svg1.select('#overall_ma_line').attr('d', overallMALine);
					}

					if ( svg3.select('#ts_filter_check_mark').style('opacity')!=1 ) {

						svg1.select('#hover_legend_null').style('opacity', 1);
						svg1.select('#overall_legend_null').style('opacity', 1);
						svg1.select('#hover_legend_line').style('opacity', 0);
						svg1.select('#overall_legend_line').style('opacity', 0);
						svg1.select('#hover_ma_line').style('opacity', 0);
						svg1.select('#overall_ma_line').style('opacity', 0);
						svg4.selectAll('#hover_metrics_instruction').style('opacity', 0);
						svg4.selectAll('#hover_metrics').remove();
					}
					else if ( svg3.select('#ts_filter_check_mark').style('opacity')==1 && hoverYear<maxYearObserved ) {

						svg1.select('#hover_legend_null').style('opacity', 0);
						svg1.select('#overall_legend_null').style('opacity', 0);
						svg1.select('#hover_legend_line').style('opacity', 1);
						svg1.select('#overall_legend_line').style('opacity', 1);
						svg1.select('#overall_ma_line').style('opacity', 1);
						svg1.select('#hover_ma_line').style('opacity', 0.85);
						svg4.selectAll('#hover_metrics_instruction').style('opacity', 0);

						// Redefine the hover line and add path
						hoverMALine = d3.line()
								.defined(function(d) { return d.index>tsSlider.value()-1; })
								.x(function(d) { return x(d.date); })
								.y(function(d) { return y(tsMADic[String(hoverYear) + '_' + String(tsSlider.value())][d.index-tsSlider.value()]); });

						svg1.select('#hover_ma_line').attr('d', hoverMALine);
					}
					else {

						svg1.select('#hover_legend_null').style('opacity', 1);
						svg1.select('#overall_legend_null').style('opacity', 0);
						svg1.select('#hover_legend_line').style('opacity', 0);
						svg1.select('#overall_legend_line').style('opacity', 1);
						svg1.select('#overall_ma_line').style('opacity', 1);
						svg1.select('#hover_ma_line').style('opacity', 0);
						svg4.selectAll('#hover_metrics_instruction').style('opacity', 1);
						svg4.selectAll('#hover_metrics').remove();
					};

					var updateHoverMetrics = function(d) {
						if ( hoverYear!=maxYearObserved ) {
							if ( dropDownSelected==overallTimeFrame )
							{ updatePastHoverMetrics(hoverYear); }
							else
							{ updateFutureHoverMetrics(hoverYear); }
						}
					};

					updateHoverMetrics();
				};
				/////////////////////////////////////////////
				/////////////////////////////////////////////

				var yearRectMO = function(d) {

						svg4.selectAll('#dropdown_option').remove();

						if ( allYears[Number(d)] < maxYearObserved ) {
							svg2.select('#hover_graph_header').style('opacity', 0);
							svg2.select('#comparing_graph_header').style('opacity', 1);
							addStdRect(svg1, null, 'hover_region_rect', 0.7, -7.5, (width/numRows)*obsCumDic[allYears[Number(d)]], height + 7.5, 'black', 1, 1, 'transparent', 1, null, null, null);
							updateGraph(allYears[Number(d)], null);
						 }
						else {
							svg2.select('#hover_graph_header').style('opacity', 1);
							svg2.select('#comparing_graph_header').style('opacity', 0);
							updateGraph(maxYearObserved, null);
						};
				},
						yearRectML = function(d) {

						svg1.select('#hover_region_rect').remove();
						svg2.select('#hover_graph_header').style('opacity', 1);
						svg2.select('#comparing_graph_header').style('opacity', 0);
						updateGraph(maxYearObserved, null);
				},
						marginMO = function(d) {

						// dropdown option remove doubled in case of failure with removal in svg4
						svg4.selectAll('#dropdown_option').remove();
						updateGraph(maxYearObserved, null);
				};

				// Add the year rect boundaries
				yearRect = svg1.selectAll()
						.data(nydKeys, function(d) { return d; })
							.enter()
						.append('rect')
							.attr('x', function(d) { return x(allDates[newYearsDayDic[d]]) + 0.7; })
							.attr('y', -7.5)
							.attr('width', function(d) { return (width/numRows)*obsPerYearDic[allYears[Number(d)]]; } )
							.attr('height', height + 7.5)
							.style('fill', 'transparent')
							.style('stroke', 'transparent')
						.on('mouseover', yearRectMO)
						.on('mouseleave', yearRectML);

				// Add the margin rect boundaries
				svg1.selectAll()
						.data(marginRectDicKeys, function(d) { return d; })
							.enter()
						.append('rect')
							.attr('x', function(d) { return marginRectDic[d]['x']; })
							.attr('y', function(d) { return marginRectDic[d]['y']; })
							.attr('width', function(d) { return marginRectDic[d]['width']; })
							.attr('height', function(d) { return marginRectDic[d]['height']; })
							.style('fill', 'transparent')
							.style('stroke', 'transparent')
						.on('mouseover', marginMO);

				// Add label and tooltip for x axis
				textInput = 'Individual incidents are summed together and grouped by date.'
				defineTooltip('graph', 'x_axis_tooltip', '457.5px', '407.5px',  '150px', '75px', 0, textInput);
				addStdRect(svg1, null, 'x_axis_tooltip_rect', (width/2) + 11, topBody + 21.5, 20, 20, 'transparent', 0, 1, 'transparent', 1, tooltipMO, tooltipML, null);
				// more specific ids will be added in the function itself.
				addTooltipSymbol(svg1, 'x_axis_tooltip', (width/2) + 21, topBody + 31.5, (width/2) + 19.5, topBody + 35.5, null);
				addStdText(svg1, null, 'x_axis_tooltip_label', -32.5, null, '18px', 'normal', 1, 0.25, 'Date');
				svg1.select('#x_axis_tooltip_label').attr('transform', 'translate(' + (width/2) + ' ,' + (topBody + 37.5) + ')');
				// Add label and tooltip for y axis
				textInput = 'Includes all victims reported as injured or killed. Victims with unreported health statuses are not included.';
				defineTooltip('graph', 'y_axis_tooltip', '50px', '105px', '185px', '90px', 0, textInput);
				addStdRect(svg1, null, 'y_axis_tooltip_rect', -65, (height/2) - 81.5, 20, 20, 'transparent', 0, 1, 'transparent', 1, tooltipMO, tooltipML, null);
				// more specific ids will be added in the function itself.
				addTooltipSymbol(svg1, 'y_axis_tooltip', -55, (height/2)-71.5, -112.5, -51, 'rotate(-90)');
				addStdText(svg1, null, 'y_axis_tooltip_label', -(height/2), 15-margin.left, '18px', 'normal', 1, 0.25, 'Total Victims');
				svg1.select('#y_axis_tooltip_label').attr('transform', 'rotate(-90)').style('text-anchor', 'middle');
			});

		</script>
	</body>
</html>
