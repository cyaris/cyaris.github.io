<!-- <!DOCTYPE html> -->
<html>
	<head>
		<title>US Gun Violence Forecasting</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<style>

		/* svg {
 			border: 1px solid #000;
 		} */

		@media (max-width:990px){
	      #check_mark_filters {
						display: none;
	      }
				#line_graph_instructions {
						display: none;
	      }
				#line_graph {
						display: none;
	      }
				#metrics_and_statistics {
						display: none;
	      }
				#data_credit {
						display: none;
	      }
	  }

	  @media (min-width:990px){
			#hidden_project_explained {
				display: none;
	    }
	  }

		.path {
		  fill: none;
		  stroke-width: 3.5px;
		}

		svg text {
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
			pointer-events: none;
		}

		div.tooltip {
		  /* position: absolute; */
		  text-align: left;
		  padding: 10px;
			font-family: 'Lora', 'Times New Roman', serif;
			font-size: 12px;
			stroke: black;
		  background: white;
		  border: solid;
			border-width: 1px;
		  border-radius: 5px;

			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
			pointer-events: none;
		}

		#lvTooltip {
			width: 265px;
			height: 120px;
		}

		#xAxisTooltip {
			width: 147.5px;
			height: 52.5px;
		}

		#yAxisTooltip {
			width: 185px;
			height: 85px;
		}

		</style>
	</head>
	<body>
		<!-- Load d3.js -->
		<script src="https://d3js.org/d3.v4.min.js"></script>
		<script src="https://unpkg.com/d3-simple-slider"></script>
		<div id="hidden_project_explained" align="left" style="margin-bottom:150px;">
			<p>While I'm flattered you came to check out my project, it has several interactive features that work best on desktop. So, grab a computer and come back soon!</p>
		</div>
		<div style="margin-top:-115px; margin-bottom:40px;">
			<div id="check_mark_filters" align="right"></div>
			<div id="line_graph_instructions" align="center" style="margin-bottom:5px;"></div>
			<!-- Create a div where the graph will take place -->
			<div id="line_graph" align="center"></div>
			<div id="metrics_and_statistics" align="center"></div>
			<div id="data_credit" align="left">
				<p>All data provided by <a href="https://gunviolencearchive.org" target="_blank">Gun Violence Archive (GVA)</a>, a not for profit corporation formed in 2013 to provide online public access to accurate information about gun-related violence in the United States.</p>
			</div>
		</div>
		<script>

			function addStdText(svgInput, idInput, textTransform, textX, textY, fontSize, strokeWidth, fontStyle, textInput) {

				svgInput.append("text")
					.attr("pointer-events", "none")
					.attr("id", idInput)
					.attr("transform", textTransform)
					.attr("x", textX)
					.attr("y", textY)
					.text(textInput)
						.style("fill", "black")
						.style("font-size", fontSize)
						.style("font-style", fontStyle)
						.style('stroke-width', strokeWidth)
						.style('stroke', function(d) {
							if ( strokeWidth==0 )
							{ return "transparent" }
							else
							 { return "black" }
						 });
			};

			function addStdRect(svgInput, idInput, rectX, rectY, rectWidth, rectHeight, rectStroke, rMouseover, rMouseleave, rClick) {

				svgInput.append("rect")
							.attr("id", idInput)
							.attr("x", rectX)
							.attr("y", rectY)
							.attr("width", rectWidth)
							.attr("height", rectHeight)
							.style("fill", "transparent")
							.style("stroke", rectStroke)
							.on("mouseover", rMouseover)
							.on("mouseleave", rMouseleave)
							.on("click", rClick);
			};

			function addStdLine(svgInput, lineX1, lineX2, lineY1, lineY2, strokeColor, strokeWidth, strokeDashArray) {

				svgInput.append("line")
						.attr("pointer-events", "none")
						.attr("x1", lineX1)
						.attr("x2", lineX2)
						.attr("y1", lineY1)
						.attr("y2", lineY2)
						.style("fill", "none")
						.style("stroke", strokeColor)
						.style("stroke-width", strokeWidth)
						.style("stroke-dasharray", strokeDashArray);
			};

			function addTooltipSymbol(svgInput, circX, circY, textX, textY, textRotate) {

				svgInput.append("circle")
							.attr("pointer-events", "none")
							.attr("cx", circX)
							.attr("cy", circY)
		 			    .attr('fill', "rgb(0,122,255)")
							.attr('opacity', 0.9)
		 			    .attr('r', 7.5);

				svgInput.append("text")
							.attr("pointer-events", "none")
							.attr("transform", textRotate)
							.attr("x", textX)
							.attr("y", textY)
							.text("i")
								.style('stroke', "white")
								.style('fill', "white")
								.style('font-size', "11.5px")
								.style('font-weight', 500);
			};

			function getTextWidth(svgInput, textInput, fontSize) {

				var textWidthArray = [];

				svgInput.append('g')
						    .selectAll('.dummyText')
						    .data([textInput])
						    .enter()
						    .append("text")
									.attr("pointer-events", "none")
							    .attr("font-size", String(fontSize) + "px")
							    .text(function(d) { return d; })
							    .each(function(d,i) {
							        var thisWidth = this.getComputedTextLength();
							        textWidthArray.push(thisWidth);
							        this.remove();
				    });

				{
					var textWidth = textWidthArray.reduce((a, b) => a + b, 0);
					return textWidth;
				}
			};
			// set the dimensions and margins of the graph
			var margin = {top: 20, right: 20, bottom: 65, left: 65},
			    width = 750 - margin.left - margin.right,
			    height = 450 - margin.top - margin.bottom,
					// and for the filter checkboxes
					checkFilterWidth = 200/7.75,
					checkFilterHeight = 40/1.65,
					leftMarginAdj = (margin.left/2)-5.5,
					leftBody = margin.left + width,
					topBody = height + margin.top,
					fullWidth = leftBody + margin.right,
					leftBodyFifth = (width+margin.left)/5,
					// set the dimensions of the margin rects
					marginRectDic = {
								0: {"x": -(margin.left), "y": -7.5,
								"width": margin.left, "height": height + 7.5},
								1: {"x": width, "y": -7.5,
								"width": margin.right, "height": height + 7.5},
								2: {"x": -(margin.left), "y": -(margin.top),
								"width": fullWidth, "height": margin.top - 7.5},
								3: {"x": -(margin.left), "y": height,
								"width": fullWidth, "height": margin.bottom},
							},
					marginRectDicKeys = Object.keys(marginRectDic);
			// parse the date / time and set the ranges
			var parseTime = d3.timeParse("%Y-%m-%d"),
					x = d3.scaleTime().range([0, width]),
					y = d3.scaleLinear().range([height, 0]);
			// append the svg object to the body of the page
			var svg1 = d3.select("#line_graph")
					.append("svg")
					  .attr("width", fullWidth)
					  .attr("height", topBody + margin.bottom)
					.append("g")
					  .attr("transform",
					        "translate(" + margin.left + "," + margin.top + ")");
			// adding svg2 here so it becomes a global variable that can be accessed by svg1
			var svg2 = d3.select("#line_graph_instructions")
					.append("svg")
						.attr("pointer-events", "none")
						.attr("width", fullWidth - leftMarginAdj)
						.attr("height", 25)
						.attr('transform', 'translate(12.5,2.5)');
			// append the svg object to the body of the page
			var svg3 = d3.select("#check_mark_filters")
					.append("svg")
					  .attr("width", 175)
					  .attr("height", 102.5)
						.attr('transform', 'translate(182.5,142)');

			var svg4 = d3.select("#metrics_and_statistics")
					.append("svg")
						.attr("width", fullWidth)
						.attr("height", 125);

			d3.csv("../assets/us_harmed_victim_forecast_data.csv", function(data) {

				var numRows = data.length,
						minYear = d3.min(data, function(d) { return d.year }),
						maxYear = d3.max(data, function(d) { return d.year });

				var	obsMaxYear = [],
						allDates = [],
						allObs = [],
						allYears = [],
						nydDic = {},
						obsPerYearDic = {},
						obsCumDic = {};
						// incidentCumDic = {};

				var numObsCumCount = 0,
						numHarmedCumCount = 0;
						// numIncidentCumCount = 0;

				var showObs = 'yes',
						showTS = 'yes';
				// format the data
				data.forEach(function(d) {
						d.date = parseTime(d.date);
						allDates.push(d.date);
						d.num_harmed = +d.num_harmed;
						allObs.push(d.num_harmed);
						// d.num_incidents = +d.num_incidents;
						if ( d.nyd!=null && d.nyd!='' ) {
							nydDic[d.nyd] = d.index
						};
				});

				for ( var i = minYear; i <= maxYear; i++ ) {
						allYears.push(i);
						daysPerYearCount = 0;
						data.forEach(function(d) {
							// numIncidentCumCount+=d.num_incidents;
							// incidentCumDic[i] = numIncidentCumCount;
							if ( d.year==i  )
							{ daysPerYearCount+=1; }
							if ( d.year==i && d.non_observation!=1 )
							{ obsMaxYear.push(i);
								numObsCumCount+=1;
								numHarmedCumCount+=d.num_harmed; }
						});
						obsPerYearDic[i] = daysPerYearCount;
						obsCumDic[i] = numObsCumCount;
				};

				var allObs = allObs.sort(function(a,b){return b-a}),
						nydKeys = Object.keys(nydDic),
						obsMaxYear = d3.max(obsMaxYear),
						maxOb = d3.max(allObs),
						// set initial yMax which will be changed as scale is adjusted
						yMax = maxOb;

				var smoothStepData = [0, 5, 10, 15, 20],
						smoothSliderStep = d3.sliderBottom()
									.min(d3.min(smoothStepData))
		    					.max(d3.max(smoothStepData))
		    					.width(100)
									.step(5)
									.tickValues(smoothStepData)
									.default(10)
									.on('onchange', function(d) {
										updateGraph(obsMaxYear, "no");
									}),
						obsMaxYearPredCol = "pred_" + String(obsMaxYear) + "_smooth_" + String(smoothSliderStep.value()),
						obsMaxYearPredColRaw = "pred_" + String(obsMaxYear) + "_smooth_" + String(d3.min(smoothStepData)),
						overallYearlyTrendCol = "yearly_trend_calc_" + String(obsMaxYear),
						overallPredPast = 0,
						overallPredFuture = 0,
						overallYearlyTrendPast = 0,
						overallYearlyTrendFuture = 0,
						overallRMSE = 0;
		    // format the data
		    data.forEach(function(d) {
		        d[obsMaxYearPredCol] = +d[obsMaxYearPredCol];
						d[obsMaxYearPredColRaw] = +d[obsMaxYearPredColRaw];
						d[overallYearlyTrendCol] = +d[overallYearlyTrendCol]
						if ( d.non_observation!=1 )
						{
							overallPredPast+=d[obsMaxYearPredColRaw]
							difference = d[obsMaxYearPredColRaw] - d.num_harmed;
							overallRMSE+=Math.pow(difference, 2)/obsCumDic[obsMaxYear];
							overallYearlyTrendPast+=d[overallYearlyTrendCol]
						}
						else
						{ overallPredFuture+=d[obsMaxYearPredColRaw]
							overallYearlyTrendFuture+=d[overallYearlyTrendCol] };
		    });

				overallRMSE = Math.round(Math.sqrt(overallRMSE)).toLocaleString();
				overallYearlyTrendPast = Math.round(overallYearlyTrendPast/(obsCumDic[obsMaxYear]-365)).toLocaleString();
				overallYearlyTrendFuture = Math.round(overallYearlyTrendFuture/365).toLocaleString();
		    // Scale the range of the data
		    x.domain(d3.extent(data, function(d) { return d.date; }));
		    y.domain([0, d3.max(data, function(d) { return d.num_harmed + 25; })]);

				var nextYearXLoc = (width/numRows)*obsCumDic[allYears[allYears.length-1]];
				addStdRect(svg1, "next_365_rect", nextYearXLoc + 0.7, -7.5, width - nextYearXLoc, height + 7.5, "black", null, null, null);
				d3.select("#next_365_rect").attr("pointer-events", "none").style("fill", "black").style("opacity", 0.075);
				addStdLine(svg1, (margin.right/2), (0.5 * margin.right) + 12.5, 6, 6, "rgb(250,98,95)", 3.5, null);
				addStdLine(svg1, (margin.right/2), (0.5 * margin.right) + 12.5, 21, 21, "rgb(0,192,127)", 3.5, null);
				addStdText(svg1, null, null, (0.5 * margin.right) + 17.5, 10, "12px", 0, "normal", "Overall Model");
				addStdText(svg1, null, null, (0.5 * margin.right) + 17.5, 25, "12px", 0, "normal", "Comparative Model");
		    // Add the circles.
		    svg1.selectAll("#circle_obs")
		        .data(data)
		        .enter()
		        .append("circle")
		          .attr("pointer-events", "none")
		          .attr("id", "circle_obs")
		          .attr("r", 2)
		          .attr("cx", function(d) { return x(d.date); })
		          .attr("cy", function(d) { return y(d.num_harmed); })
		          .style("fill", function(d) {
		            if ( d.non_observation==1 )
		            { return 'transparent' }
		            else
		            { return 'rgb(112,128,144)' }
		          })
		          .style("stroke", function(d) {
		            if ( d.non_observation==1 )
		            { return 'transparent' }
		            else
		            { return 'black' }
		          })
		          .style('stroke-width', 0.5);
		    // define the line
		    var obsMaxYearLine = d3.line()
		        .x(function(d) { return x(d.date); })
		        .y(function(d) { return y(d[obsMaxYearPredCol]); });
		    // Add the overall Pred line path.
		    svg1.append("path")
		        .data([data])
		        .attr("pointer-events", "none")
		        .attr("class", "path")
						.attr("id", "obs_max_year_line")
		        .attr("d", obsMaxYearLine)
		        .style("stroke", "rgb(250,98,95)");
				// adding incorrect hoverline to define variable early so that it's placement will be correct
				var hoverYearLine = d3.line()
		        .x(function(d) { return null; })
		        .y(function(d) { return null; });

				svg1.append("path")
		        .data([data])
		        .attr("pointer-events", "none")
		        .attr("class", "path")
						.attr("id", "hover_year_line")
		        .attr("d", hoverYearLine)
		        .style("stroke", "transparent");
				// Add the X Axis
		    svg1.append("g")
		        .attr("pointer-events", "none")
						// .attr("class", "x axis")
		        .attr("transform", "translate(0," + height + ")")
		        .style("font-size", "12px")
		        .call(d3.axisBottom(x));
		    // Add the Y Axis
		    svg1.append("g")
		        .attr("pointer-events", "none")
						.attr("class", "y axis")
		        .style("font-size", "12px")
		        .call(d3.axisLeft(y));

				var xAxisTooltip = d3.select("#line_graph")
											 .append("div")
											 	 .attr("pointer-events", "none")
												 .attr("class", "tooltip")
												 .attr("id", "xAxisTooltip")
												 .style("left", "457.5px")
												 .style("top", "422.5px")
												 .style("bottom", "0px")
												 .html("Incidents are grouped by date across the US."),
						yAxisTooltip = d3.select("#line_graph")
											 .append("div")
											 	 .attr("pointer-events", "none")
												 .attr("class", "tooltip")
												 .attr("id", "yAxisTooltip")
												 .style("left", "50px")
												 .style("top", "50px")
												 .style("bottom", "0px")
												 .html("Includes all victims reported as injured or killed. Victims with unreported injuries are not included."),
					 	xAxMouseover = function(d) {
							xAxisTooltip
								.style("opacity", 1);
							updateGraph(obsMaxYear, "no");
				},
						yAxMouseover = function(d) {
							yAxisTooltip
								.style("opacity", 1);
							updateGraph(obsMaxYear, "no");
				},
						xAxMouseleave = function(d) {
							xAxisTooltip
								.style("opacity", 0);
				},
						yAxMouseleave = function(d) {
							yAxisTooltip
								.style("opacity", 0);
				};
				// Add label for x and y axis
				addStdRect(svg1, "line_graph_outer_rect", -(margin.left/2)-5.5, -(margin.top)+.5, width+(margin.left/2)+margin.right+5, height+margin.top+(margin.bottom/2), "black", null, null, null);
				d3.select("#line_graph_outer_rect").attr("pointer-events", "none");
				addStdText(svg1, null, "translate(" + (width/2) + " ," + (topBody + 37.5) + ")", -32.5, null, "18px", 0.5, "normal", "Date");
				addStdText(svg1, "y_axis_text", "rotate(-90)", -(height/2), 15-margin.left, "18px", 0.5, "normal", "Total Victims");
				d3.select("#y_axis_text").style("text-anchor", "middle");
				addTooltipSymbol(svg1, (width/2) + 21, topBody + 32, (width/2) + 19.5, topBody + 35.5, "rotate(0)");
				addTooltipSymbol(svg1, -54, (height/2)-71.5, -112.5, -50, "rotate(-90)");

				addStdText(svg2, "hover_instruction", null, ((fullWidth - leftMarginAdj)/2)-120, 17.5, "13.5px", 0.5, "normal", "Hover to Compare Historical Forecasts");

				var generalRectHover = function(d) {
							d3.select(this)
								.style("stroke", "black")
								.style("stroke-width", 2)
								.style("cursor", "pointer");
				},
						generalRectLeave = function(d) {
							d3.select(this)
								.style("stroke", "black")
								.style("stroke-width", 1);
				},
						cursorPointer = function() {
							d3.select(this)
								.style("cursor", "pointer");
				},
						lvTooltip = d3.select("#check_mark_filters")
											 .append("div")
											 	 .attr("pointer-events", "none")
												 .attr("class", "tooltip")
												 .attr("id", "lvTooltip")
												 .style("left", "90px")
												 .style("top", "49px")
												 .html("The Las Vegas shooting is the deadliest mass shooting committed by an individual in US history. With 548 total victims killed/injured, it is a major outlier in this dataset. See how removing this observation affects the scaling of the entire graph."),
						lvMouseover = function(d) {
							lvTooltip
								.style("opacity", 1);
							updateGraph(obsMaxYear, "yes");
				},
						lvMouseleave = function(d) {
							lvTooltip
								.style("opacity", 0);
							updateGraph(obsMaxYear, "no");
				},
						lvClick = function() {
						if ( yMax==maxOb )
						{ yMax = allObs[1];
							createRectBoundaries();
							d3.select("#lvCheckMark").remove();
							updateGraph(obsMaxYear, "no");
					}
						else
						{ yMax = maxOb;
							createRectBoundaries();
							addStdText(svg3, "lvCheckMark", null, 6, 22.5, "20px", 0, "normal", "✓");
							updateGraph(obsMaxYear, "no");
						}
				},
						obsClick = function() {
						if ( showObs=="yes" )
						{ showObs = "no";
							d3.select("#obsCheckMark").remove();
							updateGraph(obsMaxYear, "no");
					}
						else
						{ showObs = "yes";
							addStdText(svg3, "obsCheckMark", null, 6, 57.5, "20px", 0, "normal", "✓");
							updateGraph(obsMaxYear, "no");
						}
				},
						tsClick = function() {
						if ( showTS=="yes" )
						{ showTS = "no";
							d3.select("#tsCheckMark").remove();
							updateGraph(obsMaxYear, "no");
					}
						else
						{ showTS = "yes";
							addStdText(svg3, "tsCheckMark", null, 6, 92.5, "20px", 0, "normal", "✓");
							updateGraph(obsMaxYear, "no");
						}
				};

				addStdRect(svg3, null, 31, 0, 175 - 33, 32.5, "transparent", lvMouseover, lvMouseleave, null);
				addStdRect(svg3, null, 1,  0, checkFilterWidth, 73.5 + checkFilterHeight + 1, "transparent", cursorPointer, null, null);
				addStdRect(svg3, null, 1,  3.5, checkFilterWidth, checkFilterHeight, "black", generalRectHover, generalRectLeave, lvClick);
				addStdRect(svg3, null, 1,  38.5, checkFilterWidth, checkFilterHeight, "black", generalRectHover, generalRectLeave, obsClick);
				addStdRect(svg3, null, 1,  73.5, checkFilterWidth, checkFilterHeight, "black", generalRectHover, generalRectLeave, tsClick);
				addTooltipSymbol(svg3, 156, 21.5, 154.5, 25, "rotate(0)");
				addStdText(svg3, "lvCheckMark", null, 6, 22.5, "20px", 0, "normal", "✓");
				addStdText(svg3, "obsCheckMark", null, 6, 57.5, "20px", 0, "normal", "✓");
				addStdText(svg3, "tsCheckMark", null, 6, 92.5, "20px", 0, "normal", "✓");
				addStdText(svg3, null, null, 34, 12, "12px", 0, "normal", "Scaled with");
				addStdText(svg3, null, null, 34, 26.5, "12px", 0, "normal", "Las Vegas Shooting");
				addStdText(svg3, null, null, 34, 47, "12px", 0, "normal", "Displaying");
				addStdText(svg3, null, null, 34, 61.5, "12px", 0, "normal", "Observations");
				addStdText(svg3, null, null, 34, 82, "12px", 0, "normal", "Displaying");
				addStdText(svg3, null, null, 34, 96.5, "12px", 0, "normal", "Time Series");

				var dropDownSelected = String(allYears[0]) + "–Present",
						dropDownOption = "Next 365 Days",
						dropDownSelectedHover = function(d) {
							d3.select(this)
								.style("stroke", "black")
								.style("stroke-width", 2)
								.style("cursor", "pointer");

							addStdRect(svg4, "dropdown_option", leftMarginAdj + 1, 32.5, 91, 17.5, "black", generalRectHover, generalRectLeave, dropDownOptionClick);
							d3.select("#dropdown_option").style("fill", "white");
							addStdText(svg4, "dropdown_option", null, leftMarginAdj + 6, 45, "12px", 0, "normal", dropDownOption);
				},
						dropDownSelectedClick = function(d) {
							d3.selectAll("#dropdown_option").remove();
							dropDownSelectedHover();
				},
						dropDownOptionClick = function(d) {
							d3.selectAll("#dropdown_option").remove();
							d3.select("#dropdown_selected_text").remove();

							if ( dropDownSelected==String(allYears[0]) + "–Present" )
							{ d3.selectAll("#past_prediction_specific").remove();
								futurePredictionSpecific();
								dropDownSelected = "Next 365 Days"
								dropDownOption = String(allYears[0]) + "–Present" }
							else
							{ d3.selectAll("#future_prediction_specific").remove();
								pastPredictionSpecific();
								dropDownSelected = String(allYears[0]) + "–Present"
								dropDownOption = "Next 365 Days" }

							addStdText(svg4, "dropdown_selected_text", null, leftMarginAdj + 6, 27.5, "12px", 0, "normal", dropDownSelected);
				},
						removeDropDownOption = function(d) {
							d3.selectAll("#dropdown_option").remove();
							updateGraph(obsMaxYear, "no");
				};

				addStdRect(svg4, null, 0, 0, fullWidth, 125, "transparent", removeDropDownOption, null, null);
				addStdRect(svg4, null, leftMarginAdj + 1, 15, 91, 17.5, "black", dropDownSelectedHover, generalRectLeave, dropDownSelectedClick);
				addStdText(svg4, "dropdown_selected_text", null, leftMarginAdj + 6, 27.5, "12px", 0, "normal", dropDownSelected);
				addTooltipSymbol(svg4, 133.5, 24, 132, 27.5, "rotate(0)");

				addStdLine(svg4, leftMarginAdj, 225.25 - 27.5, 40, 40, "black", 3.5, null);
				addStdLine(svg4, 225.25 - 27.5, 324.375 - 27.5, 40, 40, "rgb(250,98,95)", 3.5, null);
				addStdLine(svg4, 324.375 - 27.5, 423.5 - 27.5, 40, 40, "rgb(0,192,127)", 3.5, null);
				addStdText(svg4, null, null, leftMarginAdj, 9.25, "12px", 0, "normal", "Prediction Timeframe");
				var textWidthOut = getTextWidth(svg4, "Overall", 12);
				addStdText(svg4, null, null, 324.375 - 27.5 - textWidthOut, 15, "12px", 0, "normal", "Overall");
				var textWidthOut = getTextWidth(svg4, "Predictions", 12);
				addStdText(svg4, null, null, 324.375 - 27.5 - textWidthOut, 30, "12px", 0, "normal", "Predictions");
				var textWidthOut = getTextWidth(svg4, "Comparative", 12);
				addStdText(svg4, null, null, 423.5 - 27.5 - textWidthOut, 15, "12px", 0, "normal", "Comparative");
				var textWidthOut = getTextWidth(svg4, "Predictions", 12);
				addStdText(svg4, null, null, 423.5 - 27.5 - textWidthOut, 30, "12px", 0, "normal", "Predictions");

				addStdText(svg4, null, null, leftMarginAdj, 55, "12px", 0, "normal", "Model Input:");
				addStdText(svg4, null, null, leftMarginAdj, 70, "12px", 0, "normal", "Total Victims:");
				addStdText(svg4, null, null, leftMarginAdj, 85, "12px", 0, "normal", "Avg Victims per Day:");
				addStdText(svg4, null, null, leftMarginAdj, 100, "12px", 0, "normal", "Avg Yearly Trend");
				var textInput =  "Avg Yearly Trend",
						textWidthOut = getTextWidth(svg4, textInput, 12);
				addStdText(svg4, null, null, leftMarginAdj + textWidthOut + 4, 100, "12px", 0, "italic", "(Rounded)");
				var textInput =  "Avg Yearly Trend (Rounded)",
						textWidthOut = getTextWidth(svg4, textInput, 12);
				addStdText(svg4, null, null, leftMarginAdj + textWidthOut - 2, 100, "12px", 0, "normal", ":");

				var textInput =  String(allYears[0]) + "–Present",
						textWidthOut = getTextWidth(svg1, textInput, 12);
				addStdText(svg4, null, null, 324.375 - 27.5 - textWidthOut, 55, "12px", 0, "normal", textInput);

				var pastPredictionSpecific = function() {

					addStdText(svg4, "past_prediction_specific", null, leftMarginAdj, 115, "12px", 0, "normal", "RMSE");
					var textInput =  "RMSE",
							textWidthOut = getTextWidth(svg4, textInput, 12);
					addStdText(svg4, "past_prediction_specific", null, leftMarginAdj + textWidthOut + 4, 115, "12px", 0, "italic", "(Rounded)");
					var textInput =  "RMSE (Rounded)",
							textWidthOut = getTextWidth(svg4, textInput, 12);
					addStdText(svg4, "past_prediction_specific", null, leftMarginAdj + textWidthOut - 2, 115, "12px", 0, "normal", ":");

					var textInput = Math.round(overallPredPast).toLocaleString(),
							textWidthOut = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, "past_prediction_specific", null, 324.375 - 27.5 - textWidthOut, 70, "12px", 0, "normal", textInput);
					var textInput = Math.round(overallPredPast/obsCumDic[obsMaxYear]).toLocaleString(),
							textWidthOut = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, "past_prediction_specific", null, 324.375 - 27.5 - textWidthOut, 85, "12px", 0, "normal", textInput);
					var textInput = overallYearlyTrendPast.toLocaleString(),
							textWidthOut = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, "past_prediction_specific", null, 324.375 - 27.5 - textWidthOut, 100, "12px", 0, "normal", textInput);
					var textInput =  String(overallRMSE),
							textWidthOut = getTextWidth(svg4, textInput, 12);
					addStdText(svg4, "past_prediction_specific", null, 324.375 - 27.5 - textWidthOut, 115, "12px", 0, "normal", textInput);

				};

				pastPredictionSpecific();

				var futurePredictionSpecific = function() {

					var textInput = Math.round(overallPredFuture).toLocaleString(),
							textWidthOut = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, "future_prediction_specific", null, 324.375 - 27.5 - textWidthOut, 70, "12px", 0, "normal", textInput);
					var textInput = Math.round(overallPredFuture/365).toLocaleString(),
							textWidthOut = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, "future_prediction_specific", null, 324.375 - 27.5 - textWidthOut, 85, "12px", 0, "normal", textInput);
					var textInput =  overallYearlyTrendFuture.toLocaleString(),
							textWidthOut = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, "future_prediction_specific", null, 324.375 - 27.5 - textWidthOut, 100, "12px", 0, "normal", textInput);

				};

				var addHoverInstruction = function() {

						d3.selectAll("#hover_metrics").remove();

						var textInput = "Hover to",
								textWidthOut = getTextWidth(svg1, textInput, 12);
						addStdText(svg4, "hover_metrics", null, 423.5 - 27.5 - textWidthOut, 55, "12px", 0, "normal", textInput);
						var textInput = "Compare",
								textWidthOut = getTextWidth(svg1, textInput, 12);
						addStdText(svg4, "hover_metrics", null, 423.5 - 27.5 - textWidthOut, 70, "12px", 0, "normal", textInput);

				};

				addHoverInstruction();

				svg4.append('g')
						.attr('transform', 'translate(636,40)')
						.call(smoothSliderStep);

				addStdText(svg4, null, null, leftMarginAdj + (leftBodyFifth*3) + 170.5, 22.5, "12px", 0, "normal", "Model Smoothing");

		var updateGraph = function(hoverYear, highlightMax) {

		  d3.csv("../assets/us_harmed_victim_forecast_data.csv", function(data) {

		    var obsMaxYearPredCol = "pred_" + String(obsMaxYear) +  "_smooth_" + String(smoothSliderStep.value()),
						hoverYearPred = "pred_" + String(hoverYear) +  "_smooth_" + String(smoothSliderStep.value());
		    // format the data
		    data.forEach(function(d) {
		        d.date = parseTime(d.date);
		        d[obsMaxYearPredCol] = +d[obsMaxYearPredCol];
		        d[hoverYearPred] = +d[hoverYearPred];
		    });
		    // Rescale the range of the data vertically
		    y.domain([0, yMax + 25]);
		    // Update the Y Axis
		    svg1.select(".y")
		        .call(d3.axisLeft(y));
				// Update the circles.
		    svg1.selectAll("#circle_obs")
		        .attr("cy", function(d) { return y(d.num_harmed); })
						.style("fill", function(d) {
		          if ( d.non_observation==1 || showObs=='no' )
		          { return 'transparent' }
							else
		          { return 'rgb(112,128,144)' }
		        })
		        .style("stroke", function(d) {
		          if ( d.non_observation==1 || showObs=='no' )
		          { return 'transparent' }
		          else
		          { return 'black' };})
		        .style("stroke-width", function(d) {
		          if ( highlightMax=="yes" && d.num_harmed==maxOb )
		          { return 7.5; }
		          else
		          { return 0.5; }
		        })
						.style("opacity", function(d) {
		          if ( d.year > hoverYear )
		          { return 0.4 }
							else
		          { return null }
		        });
		    // Redefine the overall Pred line path.
		    var obsMaxYearLine = d3.line()
		        .x(function(d) { return x(d.date); })
		        .y(function(d) { return y(d[obsMaxYearPredCol]); });

		    svg1.select("#obs_max_year_line")
		        .attr("d", obsMaxYearLine)
		        .style("stroke", function(d) {
		          if ( showTS=='no' )
		          { return "transparent" }
		          else
		          { return "rgb(250,98,95)" };});
				// Redefine the hover_line
		    var hoverYearLine = d3.line()
		        .x(function(d) { return x(d.date); })
		        .y(function(d) { return y(d[hoverYearPred]); });

				svg1.select("#hover_year_line")
		        .attr("d", hoverYearLine)
		        .style("stroke", function(d) {
		          if ( hoverYear==obsMaxYear || showTS=='no' )
		          { return "transparent" }
		          else
		          { return "rgb(0,192,127)" };});

				var updateHoverMetrics = function(d) {
					if ( hoverYear!=obsMaxYear ) {
						if ( dropDownSelected==String(allYears[0]) + "–Present" )
						{ updatePastHoverMetrics(hoverYear); }
						else
						{ updateFutureHoverMetrics(hoverYear); }
					}
					else
					{ addHoverInstruction(); }
				};

				updateHoverMetrics();

		  });

			var updatePastHoverMetrics = function(hoverYear) {

				d3.csv("../assets/us_harmed_victim_forecast_data.csv", function(data) {

					var hoverYearPredRaw = "pred_" + String(hoverYear) +  "_smooth_" + String(d3.min(smoothStepData)),
							hoverYearlyTrendCol = "yearly_trend_calc_" + String(hoverYear),
							hoverPredPast = 0,
							hoverYearlyTrendPast = 0,
							hoverRMSE = 0;
			    // format the data
			    data.forEach(function(d) {
							d[hoverYearPredRaw] = +d[hoverYearPredRaw];
							d[hoverYearlyTrendCol] = +d[hoverYearlyTrendCol]
							if ( d.non_observation!=1 )
							{
								hoverPredPast+=d[hoverYearPredRaw]
								difference = d[hoverYearPredRaw] - d.num_harmed;
								hoverRMSE+=Math.pow(difference, 2)/obsCumDic[obsMaxYear];
								hoverYearlyTrendPast+=d[hoverYearlyTrendCol]
							}
			    });

					hoverYearlyTrendPast = Math.round(hoverYearlyTrendPast/(obsCumDic[obsMaxYear]-365)).toLocaleString();
					hoverRMSE = Math.round(Math.sqrt(hoverRMSE)).toLocaleString();

					if ( hoverYear==allYears[0] )
						{ var textInput =  String(allYears[0]); }
					else if ( hoverYear!=allYears[0] )
						{ var textInput =  String(allYears[0]) + "–" + String(hoverYear); }

					d3.selectAll("#hover_metrics").remove();

					var textWidthOut = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, "hover_metrics", null, 423.5 - 27.5 - textWidthOut, 55, "12px", 0, "normal", textInput);
					var textInput = Math.round(hoverPredPast).toLocaleString(),
							textWidthOut = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, "hover_metrics", null, 423.5 - 27.5 - textWidthOut, 70, "12px", 0, "normal", textInput);
					var textInput = Math.round(hoverPredPast/obsCumDic[obsMaxYear]).toLocaleString(),
							textWidthOut = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, "hover_metrics", null, 423.5 - 27.5 - textWidthOut, 85, "12px", 0, "normal", textInput);
					var textInput = hoverYearlyTrendPast.toLocaleString(),
							textWidthOut = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, "hover_metrics", null, 423.5 - 27.5 - textWidthOut, 100, "12px", 0, "normal", textInput);
					var textInput =  String(hoverRMSE),
							textWidthOut = getTextWidth(svg4, textInput, 12);
					addStdText(svg4, "hover_metrics", null, 423.5 - 27.5 - textWidthOut, 115, "12px", 0, "normal", textInput);

			})}

			var updateFutureHoverMetrics = function(hoverYear) {

				d3.csv("../assets/us_harmed_victim_forecast_data.csv", function(data) {

					var hoverYearPredRaw = "pred_" + String(hoverYear) +  "_smooth_" + String(d3.min(smoothStepData)),
							hoverYearlyTrendCol = "yearly_trend_calc_" + String(hoverYear),
							hoverYearlyTrendFuture = 0,
							hoverPredFuture = 0;
			    // format the data
			    data.forEach(function(d) {
							d[hoverYearPredRaw] = +d[hoverYearPredRaw];
							d[hoverYearlyTrendCol] = +d[hoverYearlyTrendCol]
							if ( d.non_observation==1 )
							{ hoverPredFuture+=d[hoverYearPredRaw]
								hoverYearlyTrendFuture+=d[hoverYearlyTrendCol] };
			    });

					hoverYearlyTrendFuture = Math.round(hoverYearlyTrendFuture/365).toLocaleString();

					if ( hoverYear==allYears[0] )
						{ var textInput =  String(allYears[0]); }
					else if ( hoverYear!=allYears[0] )
					{ var textInput =  String(allYears[0]) + "–" + String(hoverYear); }

					d3.selectAll("#hover_metrics").remove();

					var textWidthOut = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, "hover_metrics", null, 423.5 - 27.5 - textWidthOut, 55, "12px", 0, "normal", textInput);
					var textInput = Math.round(hoverPredFuture).toLocaleString(),
							textWidthOut = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, "hover_metrics", null, 423.5 - 27.5 - textWidthOut, 70, "12px", 0, "normal", textInput);
					var textInput = Math.round(hoverPredFuture/365).toLocaleString(),
							textWidthOut = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, "hover_metrics", null, 423.5 - 27.5 - textWidthOut, 85, "12px", 0, "normal", textInput);
					var textInput = hoverYearlyTrendFuture.toLocaleString(),
							textWidthOut = getTextWidth(svg1, textInput, 12);
					addStdText(svg4, "hover_metrics", null, 423.5 - 27.5 - textWidthOut, 100, "12px", 0, "normal", textInput);

			})
		};}

			var createRectBoundaries = function() {

				d3.csv("../assets/us_harmed_victim_forecast_data.csv", function(data) {
					// Format the data
					data.forEach(function(d) {
							d.date = parseTime(d.date);
					});
					// Scale the range of the data
					x.domain(d3.extent(data, function(d) { return d.date; }));
					y.domain([0, yMax + 25]);

					var yearMouseover = function(d) {

							d3.select("#hover_instruction").remove();

							if ( allYears[Number(d)] < obsMaxYear )
							{ addStdText(svg2, "hover_instruction", null, ((fullWidth - leftMarginAdj)/2)-95, 17.5, "13.5px", 0.5, "italic", "Comparing Historical Forecasts...");
								addStdRect(svg1, "hover_region_rect", 0.7, -7.5, (width/numRows)*obsCumDic[allYears[Number(d)]], height + 7.5, "black", null, null, null);
								d3.select("#hover_region_rect").attr("pointer-events", "none");
								updateGraph(allYears[Number(d)], "no");
							 }
							else
							{ addStdText(svg2, "hover_instruction", null, ((fullWidth - leftMarginAdj)/2)-120, 17.5, "13.5px", 0.5, "normal", "Hover to Compare Historical Forecasts");
								updateGraph(obsMaxYear, "no"); };
					},
						yearMouseleave = function(d) {
							d3.select("#hover_instruction").remove();
							addStdText(svg2, "hover_instruction", null, ((fullWidth - leftMarginAdj)/2)-120, 17.5, "13.5px", 0.5, "normal", "Hover to Compare Historical Forecasts");
							d3.select("#hover_region_rect").remove();
					};
						marginMouseover = function(d) {
							updateGraph(obsMaxYear, "no");
					};
					// Add the year rect boundaries
					var yearRect = svg1.selectAll()
							.data(nydKeys, function(d) { return d; })
							.enter();
					// Add the year rectangles
					yearRect.append("rect")
								.attr("x", function(d) { return x(allDates[nydDic[d]]) + 0.7; })
								.attr("y", -7.5)
								.attr("width", function(d) { return (width/numRows)*obsPerYearDic[allYears[Number(d)]]; } )
								.attr("height", height + 7.5)
								.style("fill", "transparent")
								.style("stroke", "transparent")
								.on("mouseover", yearMouseover)
								.on("mouseleave", yearMouseleave);
					// Add the margin rect boundaries
					var marginRect = svg1.selectAll()
							.data(marginRectDicKeys, function(d) { return d; })
							.enter();
					// Add the margin rectangles
					marginRect.append("rect")
							// .attr("pointer-events", "all")
							.attr("x", function(d) { return marginRectDic[d]["x"]; })
							.attr("y", function(d) { return marginRectDic[d]["y"]; })
							.attr("width", function(d) { return marginRectDic[d]["width"]; })
							.attr("height", function(d) { return marginRectDic[d]["height"]; })
							.style("fill", 'transparent')
							.style("stroke", "transparent")
							.on("mouseover", marginMouseover);

					addStdRect(svg1, null, (width/2)-40, topBody + 21, 70, 20, "transparent", xAxMouseover, xAxMouseleave, null);
					addStdRect(svg1, null, -65, (height/2)-87.5, 22.5, 145, "transparent", yAxMouseover, yAxMouseleave, null);

					addStdLine(svg1, nextYearXLoc + 0.7, nextYearXLoc + 0.7, function(d) { return y(y.domain()[0])}, -7.5, "black", 2, ("4, 4"));
					addStdLine(svg1, nextYearXLoc + 0.7, width, -7.5, -7.5, "black", 2, ("4, 4"));
					var textInput =  "Next 365 Days...",
							textWidthOut = getTextWidth(svg1, textInput, 12);
					addStdText(svg1, null, null, nextYearXLoc + 0.7 + ((width - nextYearXLoc - textWidthOut)/2), 10, "12px", 0, "italic", textInput);

				});
			};

			createRectBoundaries();

		});

		</script>
	</body>
</html>
